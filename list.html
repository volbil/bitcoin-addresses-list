<html>
	<head>
		<meta charset="utf-8">
		<title>Bitcoin Address List</title>
		<meta name="description" content="Bitcoin Address List | Made with love by Volbil">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimum-scale=1.0, maximum-scale=1.0">
		<link href="https://fonts.googleapis.com/css?family=IBM+Plex+Mono:400,700" rel="stylesheet">
		<link href="data:image/png;base64,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" rel="icon" type="image/x-icon"/>
		<script>
			/*
			 * Crypto-JS v2.5.4
			 * http://code.google.com/p/crypto-js/
			 * (c) 2009-2012 by Jeff Mott. All rights reserved.
			 * http://code.google.com/p/crypto-js/wiki/License
			 */
			(typeof Crypto=="undefined"||!Crypto.util)&&function(){var f=window.Crypto={},l=f.util={rotl:function(b,a){return b<<a|b>>>32-a},rotr:function(b,a){return b<<32-a|b>>>a},endian:function(b){if(b.constructor==Number)return l.rotl(b,8)&16711935|l.rotl(b,24)&4278255360;for(var a=0;a<b.length;a++)b[a]=l.endian(b[a]);return b},randomBytes:function(b){for(var a=[];b>0;b--)a.push(Math.floor(Math.random()*256));return a},bytesToWords:function(b){for(var a=[],c=0,d=0;c<b.length;c++,d+=8)a[d>>>5]|=(b[c]&255)<<
			24-d%32;return a},wordsToBytes:function(b){for(var a=[],c=0;c<b.length*32;c+=8)a.push(b[c>>>5]>>>24-c%32&255);return a},bytesToHex:function(b){for(var a=[],c=0;c<b.length;c++)a.push((b[c]>>>4).toString(16)),a.push((b[c]&15).toString(16));return a.join("")},hexToBytes:function(b){for(var a=[],c=0;c<b.length;c+=2)a.push(parseInt(b.substr(c,2),16));return a},bytesToBase64:function(b){for(var a=[],c=0;c<b.length;c+=3)for(var d=b[c]<<16|b[c+1]<<8|b[c+2],q=0;q<4;q++)c*8+q*6<=b.length*8?a.push("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(d>>>
			6*(3-q)&63)):a.push("=");return a.join("")},base64ToBytes:function(b){for(var b=b.replace(/[^A-Z0-9+\/]/ig,""),a=[],c=0,d=0;c<b.length;d=++c%4)d!=0&&a.push(("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(b.charAt(c-1))&Math.pow(2,-2*d+8)-1)<<d*2|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(b.charAt(c))>>>6-d*2);return a}},f=f.charenc={};f.UTF8={stringToBytes:function(b){return i.stringToBytes(unescape(encodeURIComponent(b)))},bytesToString:function(b){return decodeURIComponent(escape(i.bytesToString(b)))}};
			var i=f.Binary={stringToBytes:function(b){for(var a=[],c=0;c<b.length;c++)a.push(b.charCodeAt(c)&255);return a},bytesToString:function(b){for(var a=[],c=0;c<b.length;c++)a.push(String.fromCharCode(b[c]));return a.join("")}}}();
			(function(){var f=Crypto,l=f.util,i=f.charenc,b=i.UTF8,a=i.Binary,c=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,
			2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298],d=f.SHA256=function(b,c){var e=l.wordsToBytes(d._sha256(b));return c&&c.asBytes?e:c&&c.asString?a.bytesToString(e):l.bytesToHex(e)};d._sha256=function(a){a.constructor==String&&(a=b.stringToBytes(a));var d=l.bytesToWords(a),e=a.length*8,a=[1779033703,3144134277,
			1013904242,2773480762,1359893119,2600822924,528734635,1541459225],f=[],m,n,i,h,o,p,r,s,g,k,j;d[e>>5]|=128<<24-e%32;d[(e+64>>9<<4)+15]=e;for(s=0;s<d.length;s+=16){e=a[0];m=a[1];n=a[2];i=a[3];h=a[4];o=a[5];p=a[6];r=a[7];for(g=0;g<64;g++){g<16?f[g]=d[g+s]:(k=f[g-15],j=f[g-2],f[g]=((k<<25|k>>>7)^(k<<14|k>>>18)^k>>>3)+(f[g-7]>>>0)+((j<<15|j>>>17)^(j<<13|j>>>19)^j>>>10)+(f[g-16]>>>0));j=e&m^e&n^m&n;var t=(e<<30|e>>>2)^(e<<19|e>>>13)^(e<<10|e>>>22);k=(r>>>0)+((h<<26|h>>>6)^(h<<21|h>>>11)^(h<<7|h>>>25))+
			(h&o^~h&p)+c[g]+(f[g]>>>0);j=t+j;r=p;p=o;o=h;h=i+k>>>0;i=n;n=m;m=e;e=k+j>>>0}a[0]+=e;a[1]+=m;a[2]+=n;a[3]+=i;a[4]+=h;a[5]+=o;a[6]+=p;a[7]+=r}return a};d._blocksize=16;d._digestsize=32})();

			// Copyright (c) 2005  Tom Wu
			// All Rights Reserved.
			// See "LICENSE" for details.

			// Basic JavaScript BN library - subset useful for RSA encryption.

			// Bits per digit
			var dbits;

			// JavaScript engine analysis
			var canary = 0xdeadbeefcafe;
			var j_lm = ((canary&0xffffff)==0xefcafe);

			// (public) Constructor
			function BigInteger(a,b,c) {
			  if (!(this instanceof BigInteger)) {
			    return new BigInteger(a, b, c);
			  }

			  if(a != null) {
			    if("number" == typeof a) this.fromNumber(a,b,c);
			    else if(b == null && "string" != typeof a) this.fromString(a,256);
			    else this.fromString(a,b);
			  }
			}

			var proto = BigInteger.prototype;

			// return new, unset BigInteger
			function nbi() { return new BigInteger(null); }

			// am: Compute w_j += (x*this_i), propagate carries,
			// c is initial carry, returns final carry.
			// c < 3*dvalue, x < 2*dvalue, this_i < dvalue
			// We need to select the fastest one that works in this environment.

			// am1: use a single mult and divide to get the high bits,
			// max digit bits should be 26 because
			// max internal value = 2*dvalue^2-2*dvalue (< 2^53)
			function am1(i,x,w,j,c,n) {
			  while(--n >= 0) {
			    var v = x*this[i++]+w[j]+c;
			    c = Math.floor(v/0x4000000);
			    w[j++] = v&0x3ffffff;
			  }
			  return c;
			}
			// am2 avoids a big mult-and-extract completely.
			// Max digit bits should be <= 30 because we do bitwise ops
			// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
			function am2(i,x,w,j,c,n) {
			  var xl = x&0x7fff, xh = x>>15;
			  while(--n >= 0) {
			    var l = this[i]&0x7fff;
			    var h = this[i++]>>15;
			    var m = xh*l+h*xl;
			    l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);
			    c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);
			    w[j++] = l&0x3fffffff;
			  }
			  return c;
			}
			// Alternately, set max digit bits to 28 since some
			// browsers slow down when dealing with 32-bit numbers.
			function am3(i,x,w,j,c,n) {
			  var xl = x&0x3fff, xh = x>>14;
			  while(--n >= 0) {
			    var l = this[i]&0x3fff;
			    var h = this[i++]>>14;
			    var m = xh*l+h*xl;
			    l = xl*l+((m&0x3fff)<<14)+w[j]+c;
			    c = (l>>28)+(m>>14)+xh*h;
			    w[j++] = l&0xfffffff;
			  }
			  return c;
			}

			// wtf?
			BigInteger.prototype.am = am1;
			dbits = 26;

			/*
			if(j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
			  BigInteger.prototype.am = am2;
			  dbits = 30;
			}
			else if(j_lm && (navigator.appName != "Netscape")) {
			  BigInteger.prototype.am = am1;
			  dbits = 26;
			}
			else { // Mozilla/Netscape seems to prefer am3
			  BigInteger.prototype.am = am3;
			  dbits = 28;
			}
			*/

			BigInteger.prototype.DB = dbits;
			BigInteger.prototype.DM = ((1<<dbits)-1);
			var DV = BigInteger.prototype.DV = (1<<dbits);

			var BI_FP = 52;
			BigInteger.prototype.FV = Math.pow(2,BI_FP);
			BigInteger.prototype.F1 = BI_FP-dbits;
			BigInteger.prototype.F2 = 2*dbits-BI_FP;

			// Digit conversions
			var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
			var BI_RC = new Array();
			var rr,vv;
			rr = "0".charCodeAt(0);
			for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
			rr = "a".charCodeAt(0);
			for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
			rr = "A".charCodeAt(0);
			for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

			function int2char(n) { return BI_RM.charAt(n); }
			function intAt(s,i) {
			  var c = BI_RC[s.charCodeAt(i)];
			  return (c==null)?-1:c;
			}

			// (protected) copy this to r
			function bnpCopyTo(r) {
			  for(var i = this.t-1; i >= 0; --i) r[i] = this[i];
			  r.t = this.t;
			  r.s = this.s;
			}

			// (protected) set from integer value x, -DV <= x < DV
			function bnpFromInt(x) {
			  this.t = 1;
			  this.s = (x<0)?-1:0;
			  if(x > 0) this[0] = x;
			  else if(x < -1) this[0] = x+DV;
			  else this.t = 0;
			}

			// return bigint initialized to value
			function nbv(i) { var r = nbi(); r.fromInt(i); return r; }

			// (protected) set from string and radix
			function bnpFromString(s,b) {
			  var self = this;

			  var k;
			  if(b == 16) k = 4;
			  else if(b == 8) k = 3;
			  else if(b == 256) k = 8; // byte array
			  else if(b == 2) k = 1;
			  else if(b == 32) k = 5;
			  else if(b == 4) k = 2;
			  else { self.fromRadix(s,b); return; }
			  self.t = 0;
			  self.s = 0;
			  var i = s.length, mi = false, sh = 0;
			  while(--i >= 0) {
			    var x = (k==8)?s[i]&0xff:intAt(s,i);
			    if(x < 0) {
			      if(s.charAt(i) == "-") mi = true;
			      continue;
			    }
			    mi = false;
			    if(sh == 0)
			      self[self.t++] = x;
			    else if(sh+k > self.DB) {
			      self[self.t-1] |= (x&((1<<(self.DB-sh))-1))<<sh;
			      self[self.t++] = (x>>(self.DB-sh));
			    }
			    else
			      self[self.t-1] |= x<<sh;
			    sh += k;
			    if(sh >= self.DB) sh -= self.DB;
			  }
			  if(k == 8 && (s[0]&0x80) != 0) {
			    self.s = -1;
			    if(sh > 0) self[self.t-1] |= ((1<<(self.DB-sh))-1)<<sh;
			  }
			  self.clamp();
			  if(mi) BigInteger.ZERO.subTo(self,self);
			}

			// (protected) clamp off excess high words
			function bnpClamp() {
			  var c = this.s&this.DM;
			  while(this.t > 0 && this[this.t-1] == c) --this.t;
			}

			// (public) return string representation in given radix
			function bnToString(b) {
			  var self = this;
			  if(self.s < 0) return "-"+self.negate().toString(b);
			  var k;
			  if(b == 16) k = 4;
			  else if(b == 8) k = 3;
			  else if(b == 2) k = 1;
			  else if(b == 32) k = 5;
			  else if(b == 4) k = 2;
			  else return self.toRadix(b);
			  var km = (1<<k)-1, d, m = false, r = "", i = self.t;
			  var p = self.DB-(i*self.DB)%k;
			  if(i-- > 0) {
			    if(p < self.DB && (d = self[i]>>p) > 0) { m = true; r = int2char(d); }
			    while(i >= 0) {
			      if(p < k) {
			        d = (self[i]&((1<<p)-1))<<(k-p);
			        d |= self[--i]>>(p+=self.DB-k);
			      }
			      else {
			        d = (self[i]>>(p-=k))&km;
			        if(p <= 0) { p += self.DB; --i; }
			      }
			      if(d > 0) m = true;
			      if(m) r += int2char(d);
			    }
			  }
			  return m?r:"0";
			}

			// (public) -this
			function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }

			// (public) |this|
			function bnAbs() { return (this.s<0)?this.negate():this; }

			// (public) return + if this > a, - if this < a, 0 if equal
			function bnCompareTo(a) {
			  var r = this.s-a.s;
			  if(r != 0) return r;
			  var i = this.t;
			  r = i-a.t;
			  if(r != 0) return (this.s<0)?-r:r;
			  while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;
			  return 0;
			}

			// returns bit length of the integer x
			function nbits(x) {
			  var r = 1, t;
			  if((t=x>>>16) != 0) { x = t; r += 16; }
			  if((t=x>>8) != 0) { x = t; r += 8; }
			  if((t=x>>4) != 0) { x = t; r += 4; }
			  if((t=x>>2) != 0) { x = t; r += 2; }
			  if((t=x>>1) != 0) { x = t; r += 1; }
			  return r;
			}

			// (public) return the number of bits in "this"
			function bnBitLength() {
			  if(this.t <= 0) return 0;
			  return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));
			}

			// (protected) r = this << n*DB
			function bnpDLShiftTo(n,r) {
			  var i;
			  for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];
			  for(i = n-1; i >= 0; --i) r[i] = 0;
			  r.t = this.t+n;
			  r.s = this.s;
			}

			// (protected) r = this >> n*DB
			function bnpDRShiftTo(n,r) {
			  for(var i = n; i < this.t; ++i) r[i-n] = this[i];
			  r.t = Math.max(this.t-n,0);
			  r.s = this.s;
			}

			// (protected) r = this << n
			function bnpLShiftTo(n,r) {
			  var self = this;
			  var bs = n%self.DB;
			  var cbs = self.DB-bs;
			  var bm = (1<<cbs)-1;
			  var ds = Math.floor(n/self.DB), c = (self.s<<bs)&self.DM, i;
			  for(i = self.t-1; i >= 0; --i) {
			    r[i+ds+1] = (self[i]>>cbs)|c;
			    c = (self[i]&bm)<<bs;
			  }
			  for(i = ds-1; i >= 0; --i) r[i] = 0;
			  r[ds] = c;
			  r.t = self.t+ds+1;
			  r.s = self.s;
			  r.clamp();
			}

			// (protected) r = this >> n
			function bnpRShiftTo(n,r) {
			  var self = this;
			  r.s = self.s;
			  var ds = Math.floor(n/self.DB);
			  if(ds >= self.t) { r.t = 0; return; }
			  var bs = n%self.DB;
			  var cbs = self.DB-bs;
			  var bm = (1<<bs)-1;
			  r[0] = self[ds]>>bs;
			  for(var i = ds+1; i < self.t; ++i) {
			    r[i-ds-1] |= (self[i]&bm)<<cbs;
			    r[i-ds] = self[i]>>bs;
			  }
			  if(bs > 0) r[self.t-ds-1] |= (self.s&bm)<<cbs;
			  r.t = self.t-ds;
			  r.clamp();
			}

			// (protected) r = this - a
			function bnpSubTo(a,r) {
			  var self = this;
			  var i = 0, c = 0, m = Math.min(a.t,self.t);
			  while(i < m) {
			    c += self[i]-a[i];
			    r[i++] = c&self.DM;
			    c >>= self.DB;
			  }
			  if(a.t < self.t) {
			    c -= a.s;
			    while(i < self.t) {
			      c += self[i];
			      r[i++] = c&self.DM;
			      c >>= self.DB;
			    }
			    c += self.s;
			  }
			  else {
			    c += self.s;
			    while(i < a.t) {
			      c -= a[i];
			      r[i++] = c&self.DM;
			      c >>= self.DB;
			    }
			    c -= a.s;
			  }
			  r.s = (c<0)?-1:0;
			  if(c < -1) r[i++] = self.DV+c;
			  else if(c > 0) r[i++] = c;
			  r.t = i;
			  r.clamp();
			}

			// (protected) r = this * a, r != this,a (HAC 14.12)
			// "this" should be the larger one if appropriate.
			function bnpMultiplyTo(a,r) {
			  var x = this.abs(), y = a.abs();
			  var i = x.t;
			  r.t = i+y.t;
			  while(--i >= 0) r[i] = 0;
			  for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);
			  r.s = 0;
			  r.clamp();
			  if(this.s != a.s) BigInteger.ZERO.subTo(r,r);
			}

			// (protected) r = this^2, r != this (HAC 14.16)
			function bnpSquareTo(r) {
			  var x = this.abs();
			  var i = r.t = 2*x.t;
			  while(--i >= 0) r[i] = 0;
			  for(i = 0; i < x.t-1; ++i) {
			    var c = x.am(i,x[i],r,2*i,0,1);
			    if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {
			      r[i+x.t] -= x.DV;
			      r[i+x.t+1] = 1;
			    }
			  }
			  if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);
			  r.s = 0;
			  r.clamp();
			}

			// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
			// r != q, this != m.  q or r may be null.
			function bnpDivRemTo(m,q,r) {
			  var self = this;
			  var pm = m.abs();
			  if(pm.t <= 0) return;
			  var pt = self.abs();
			  if(pt.t < pm.t) {
			    if(q != null) q.fromInt(0);
			    if(r != null) self.copyTo(r);
			    return;
			  }
			  if(r == null) r = nbi();
			  var y = nbi(), ts = self.s, ms = m.s;
			  var nsh = self.DB-nbits(pm[pm.t-1]);	// normalize modulus
			  if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }
			  else { pm.copyTo(y); pt.copyTo(r); }
			  var ys = y.t;
			  var y0 = y[ys-1];
			  if(y0 == 0) return;
			  var yt = y0*(1<<self.F1)+((ys>1)?y[ys-2]>>self.F2:0);
			  var d1 = self.FV/yt, d2 = (1<<self.F1)/yt, e = 1<<self.F2;
			  var i = r.t, j = i-ys, t = (q==null)?nbi():q;
			  y.dlShiftTo(j,t);
			  if(r.compareTo(t) >= 0) {
			    r[r.t++] = 1;
			    r.subTo(t,r);
			  }
			  BigInteger.ONE.dlShiftTo(ys,t);
			  t.subTo(y,y);	// "negative" y so we can replace sub with am later
			  while(y.t < ys) y[y.t++] = 0;
			  while(--j >= 0) {
			    // Estimate quotient digit
			    var qd = (r[--i]==y0)?self.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);
			    if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {	// Try it out
			      y.dlShiftTo(j,t);
			      r.subTo(t,r);
			      while(r[i] < --qd) r.subTo(t,r);
			    }
			  }
			  if(q != null) {
			    r.drShiftTo(ys,q);
			    if(ts != ms) BigInteger.ZERO.subTo(q,q);
			  }
			  r.t = ys;
			  r.clamp();
			  if(nsh > 0) r.rShiftTo(nsh,r);	// Denormalize remainder
			  if(ts < 0) BigInteger.ZERO.subTo(r,r);
			}

			// (public) this mod a
			function bnMod(a) {
			  var r = nbi();
			  this.abs().divRemTo(a,null,r);
			  if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);
			  return r;
			}

			// Modular reduction using "classic" algorithm
			function Classic(m) { this.m = m; }
			function cConvert(x) {
			  if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
			  else return x;
			}
			function cRevert(x) { return x; }
			function cReduce(x) { x.divRemTo(this.m,null,x); }
			function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
			function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

			Classic.prototype.convert = cConvert;
			Classic.prototype.revert = cRevert;
			Classic.prototype.reduce = cReduce;
			Classic.prototype.mulTo = cMulTo;
			Classic.prototype.sqrTo = cSqrTo;

			// (protected) return "-1/this % 2^DB"; useful for Mont. reduction
			// justification:
			//         xy == 1 (mod m)
			//         xy =  1+km
			//   xy(2-xy) = (1+km)(1-km)
			// x[y(2-xy)] = 1-k^2m^2
			// x[y(2-xy)] == 1 (mod m^2)
			// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
			// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
			// JS multiply "overflows" differently from C/C++, so care is needed here.
			function bnpInvDigit() {
			  if(this.t < 1) return 0;
			  var x = this[0];
			  if((x&1) == 0) return 0;
			  var y = x&3;		// y == 1/x mod 2^2
			  y = (y*(2-(x&0xf)*y))&0xf;	// y == 1/x mod 2^4
			  y = (y*(2-(x&0xff)*y))&0xff;	// y == 1/x mod 2^8
			  y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;	// y == 1/x mod 2^16
			  // last step - calculate inverse mod DV directly;
			  // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
			  y = (y*(2-x*y%this.DV))%this.DV;		// y == 1/x mod 2^dbits
			  // we really want the negative inverse, and -DV < y < DV
			  return (y>0)?this.DV-y:-y;
			}

			// Montgomery reduction
			function Montgomery(m) {
			  this.m = m;
			  this.mp = m.invDigit();
			  this.mpl = this.mp&0x7fff;
			  this.mph = this.mp>>15;
			  this.um = (1<<(m.DB-15))-1;
			  this.mt2 = 2*m.t;
			}

			// xR mod m
			function montConvert(x) {
			  var r = nbi();
			  x.abs().dlShiftTo(this.m.t,r);
			  r.divRemTo(this.m,null,r);
			  if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);
			  return r;
			}

			// x/R mod m
			function montRevert(x) {
			  var r = nbi();
			  x.copyTo(r);
			  this.reduce(r);
			  return r;
			}

			// x = x/R mod m (HAC 14.32)
			function montReduce(x) {
			  while(x.t <= this.mt2)	// pad x so am has enough room later
			    x[x.t++] = 0;
			  for(var i = 0; i < this.m.t; ++i) {
			    // faster way of calculating u0 = x[i]*mp mod DV
			    var j = x[i]&0x7fff;
			    var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;
			    // use am to combine the multiply-shift-add into one call
			    j = i+this.m.t;
			    x[j] += this.m.am(0,u0,x,i,0,this.m.t);
			    // propagate carry
			    while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }
			  }
			  x.clamp();
			  x.drShiftTo(this.m.t,x);
			  if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
			}

			// r = "x^2/R mod m"; x != r
			function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

			// r = "xy/R mod m"; x,y != r
			function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

			Montgomery.prototype.convert = montConvert;
			Montgomery.prototype.revert = montRevert;
			Montgomery.prototype.reduce = montReduce;
			Montgomery.prototype.mulTo = montMulTo;
			Montgomery.prototype.sqrTo = montSqrTo;

			// (protected) true iff this is even
			function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }

			// (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
			function bnpExp(e,z) {
			  if(e > 0xffffffff || e < 1) return BigInteger.ONE;
			  var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;
			  g.copyTo(r);
			  while(--i >= 0) {
			    z.sqrTo(r,r2);
			    if((e&(1<<i)) > 0) z.mulTo(r2,g,r);
			    else { var t = r; r = r2; r2 = t; }
			  }
			  return z.revert(r);
			}

			// (public) this^e % m, 0 <= e < 2^32
			function bnModPowInt(e,m) {
			  var z;
			  if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
			  return this.exp(e,z);
			}

			// protected
			proto.copyTo = bnpCopyTo;
			proto.fromInt = bnpFromInt;
			proto.fromString = bnpFromString;
			proto.clamp = bnpClamp;
			proto.dlShiftTo = bnpDLShiftTo;
			proto.drShiftTo = bnpDRShiftTo;
			proto.lShiftTo = bnpLShiftTo;
			proto.rShiftTo = bnpRShiftTo;
			proto.subTo = bnpSubTo;
			proto.multiplyTo = bnpMultiplyTo;
			proto.squareTo = bnpSquareTo;
			proto.divRemTo = bnpDivRemTo;
			proto.invDigit = bnpInvDigit;
			proto.isEven = bnpIsEven;
			proto.exp = bnpExp;

			// public
			proto.toString = bnToString;
			proto.negate = bnNegate;
			proto.abs = bnAbs;
			proto.compareTo = bnCompareTo;
			proto.bitLength = bnBitLength;
			proto.mod = bnMod;
			proto.modPowInt = bnModPowInt;

			//// jsbn2

			function nbi() { return new BigInteger(null); }

			// (public)
			function bnClone() { var r = nbi(); this.copyTo(r); return r; }

			// (public) return value as integer
			function bnIntValue() {
			  if(this.s < 0) {
			    if(this.t == 1) return this[0]-this.DV;
			    else if(this.t == 0) return -1;
			  }
			  else if(this.t == 1) return this[0];
			  else if(this.t == 0) return 0;
			  // assumes 16 < DB < 32
			  return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];
			}

			// (public) return value as byte
			function bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }

			// (public) return value as short (assumes DB>=16)
			function bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }

			// (protected) return x s.t. r^x < DV
			function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }

			// (public) 0 if this == 0, 1 if this > 0
			function bnSigNum() {
			  if(this.s < 0) return -1;
			  else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
			  else return 1;
			}

			// (protected) convert to radix string
			function bnpToRadix(b) {
			  if(b == null) b = 10;
			  if(this.signum() == 0 || b < 2 || b > 36) return "0";
			  var cs = this.chunkSize(b);
			  var a = Math.pow(b,cs);
			  var d = nbv(a), y = nbi(), z = nbi(), r = "";
			  this.divRemTo(d,y,z);
			  while(y.signum() > 0) {
			    r = (a+z.intValue()).toString(b).substr(1) + r;
			    y.divRemTo(d,y,z);
			  }
			  return z.intValue().toString(b) + r;
			}

			// (protected) convert from radix string
			function bnpFromRadix(s,b) {
			  var self = this;
			  self.fromInt(0);
			  if(b == null) b = 10;
			  var cs = self.chunkSize(b);
			  var d = Math.pow(b,cs), mi = false, j = 0, w = 0;
			  for(var i = 0; i < s.length; ++i) {
			    var x = intAt(s,i);
			    if(x < 0) {
			      if(s.charAt(i) == "-" && self.signum() == 0) mi = true;
			      continue;
			    }
			    w = b*w+x;
			    if(++j >= cs) {
			      self.dMultiply(d);
			      self.dAddOffset(w,0);
			      j = 0;
			      w = 0;
			    }
			  }
			  if(j > 0) {
			    self.dMultiply(Math.pow(b,j));
			    self.dAddOffset(w,0);
			  }
			  if(mi) BigInteger.ZERO.subTo(self,self);
			}

			// (protected) alternate constructor
			function bnpFromNumber(a,b,c) {
			  var self = this;
			  if("number" == typeof b) {
			    // new BigInteger(int,int,RNG)
			    if(a < 2) self.fromInt(1);
			    else {
			      self.fromNumber(a,c);
			      if(!self.testBit(a-1))	// force MSB set
			        self.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,self);
			      if(self.isEven()) self.dAddOffset(1,0); // force odd
			      while(!self.isProbablePrime(b)) {
			        self.dAddOffset(2,0);
			        if(self.bitLength() > a) self.subTo(BigInteger.ONE.shiftLeft(a-1),self);
			      }
			    }
			  }
			  else {
			    // new BigInteger(int,RNG)
			    var x = new Array(), t = a&7;
			    x.length = (a>>3)+1;
			    b.nextBytes(x);
			    if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;
			    self.fromString(x,256);
			  }
			}

			// (public) convert to bigendian byte array
			function bnToByteArray() {
			  var self = this;
			  var i = self.t, r = new Array();
			  r[0] = self.s;
			  var p = self.DB-(i*self.DB)%8, d, k = 0;
			  if(i-- > 0) {
			    if(p < self.DB && (d = self[i]>>p) != (self.s&self.DM)>>p)
			      r[k++] = d|(self.s<<(self.DB-p));
			    while(i >= 0) {
			      if(p < 8) {
			        d = (self[i]&((1<<p)-1))<<(8-p);
			        d |= self[--i]>>(p+=self.DB-8);
			      }
			      else {
			        d = (self[i]>>(p-=8))&0xff;
			        if(p <= 0) { p += self.DB; --i; }
			      }
			      if((d&0x80) != 0) d |= -256;
			      if(k === 0 && (self.s&0x80) != (d&0x80)) ++k;
			      if(k > 0 || d != self.s) r[k++] = d;
			    }
			  }
			  return r;
			}

			function bnEquals(a) { return(this.compareTo(a)==0); }
			function bnMin(a) { return(this.compareTo(a)<0)?this:a; }
			function bnMax(a) { return(this.compareTo(a)>0)?this:a; }

			// (protected) r = this op a (bitwise)
			function bnpBitwiseTo(a,op,r) {
			  var self = this;
			  var i, f, m = Math.min(a.t,self.t);
			  for(i = 0; i < m; ++i) r[i] = op(self[i],a[i]);
			  if(a.t < self.t) {
			    f = a.s&self.DM;
			    for(i = m; i < self.t; ++i) r[i] = op(self[i],f);
			    r.t = self.t;
			  }
			  else {
			    f = self.s&self.DM;
			    for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);
			    r.t = a.t;
			  }
			  r.s = op(self.s,a.s);
			  r.clamp();
			}

			// (public) this & a
			function op_and(x,y) { return x&y; }
			function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }

			// (public) this | a
			function op_or(x,y) { return x|y; }
			function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }

			// (public) this ^ a
			function op_xor(x,y) { return x^y; }
			function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }

			// (public) this & ~a
			function op_andnot(x,y) { return x&~y; }
			function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }

			// (public) ~this
			function bnNot() {
			  var r = nbi();
			  for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];
			  r.t = this.t;
			  r.s = ~this.s;
			  return r;
			}

			// (public) this << n
			function bnShiftLeft(n) {
			  var r = nbi();
			  if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);
			  return r;
			}

			// (public) this >> n
			function bnShiftRight(n) {
			  var r = nbi();
			  if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);
			  return r;
			}

			// return index of lowest 1-bit in x, x < 2^31
			function lbit(x) {
			  if(x == 0) return -1;
			  var r = 0;
			  if((x&0xffff) == 0) { x >>= 16; r += 16; }
			  if((x&0xff) == 0) { x >>= 8; r += 8; }
			  if((x&0xf) == 0) { x >>= 4; r += 4; }
			  if((x&3) == 0) { x >>= 2; r += 2; }
			  if((x&1) == 0) ++r;
			  return r;
			}

			// (public) returns index of lowest 1-bit (or -1 if none)
			function bnGetLowestSetBit() {
			  for(var i = 0; i < this.t; ++i)
			    if(this[i] != 0) return i*this.DB+lbit(this[i]);
			  if(this.s < 0) return this.t*this.DB;
			  return -1;
			}

			// return number of 1 bits in x
			function cbit(x) {
			  var r = 0;
			  while(x != 0) { x &= x-1; ++r; }
			  return r;
			}

			// (public) return number of set bits
			function bnBitCount() {
			  var r = 0, x = this.s&this.DM;
			  for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);
			  return r;
			}

			// (public) true iff nth bit is set
			function bnTestBit(n) {
			  var j = Math.floor(n/this.DB);
			  if(j >= this.t) return(this.s!=0);
			  return((this[j]&(1<<(n%this.DB)))!=0);
			}

			// (protected) this op (1<<n)
			function bnpChangeBit(n,op) {
			  var r = BigInteger.ONE.shiftLeft(n);
			  this.bitwiseTo(r,op,r);
			  return r;
			}

			// (public) this | (1<<n)
			function bnSetBit(n) { return this.changeBit(n,op_or); }

			// (public) this & ~(1<<n)
			function bnClearBit(n) { return this.changeBit(n,op_andnot); }

			// (public) this ^ (1<<n)
			function bnFlipBit(n) { return this.changeBit(n,op_xor); }

			// (protected) r = this + a
			function bnpAddTo(a,r) {
			  var self = this;

			  var i = 0, c = 0, m = Math.min(a.t,self.t);
			  while(i < m) {
			    c += self[i]+a[i];
			    r[i++] = c&self.DM;
			    c >>= self.DB;
			  }
			  if(a.t < self.t) {
			    c += a.s;
			    while(i < self.t) {
			      c += self[i];
			      r[i++] = c&self.DM;
			      c >>= self.DB;
			    }
			    c += self.s;
			  }
			  else {
			    c += self.s;
			    while(i < a.t) {
			      c += a[i];
			      r[i++] = c&self.DM;
			      c >>= self.DB;
			    }
			    c += a.s;
			  }
			  r.s = (c<0)?-1:0;
			  if(c > 0) r[i++] = c;
			  else if(c < -1) r[i++] = self.DV+c;
			  r.t = i;
			  r.clamp();
			}

			// (public) this + a
			function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }

			// (public) this - a
			function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }

			// (public) this * a
			function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }

			// (public) this^2
			function bnSquare() { var r = nbi(); this.squareTo(r); return r; }

			// (public) this / a
			function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }

			// (public) this % a
			function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }

			// (public) [this/a,this%a]
			function bnDivideAndRemainder(a) {
			  var q = nbi(), r = nbi();
			  this.divRemTo(a,q,r);
			  return new Array(q,r);
			}

			// (protected) this *= n, this >= 0, 1 < n < DV
			function bnpDMultiply(n) {
			  this[this.t] = this.am(0,n-1,this,0,0,this.t);
			  ++this.t;
			  this.clamp();
			}

			// (protected) this += n << w words, this >= 0
			function bnpDAddOffset(n,w) {
			  if(n == 0) return;
			  while(this.t <= w) this[this.t++] = 0;
			  this[w] += n;
			  while(this[w] >= this.DV) {
			    this[w] -= this.DV;
			    if(++w >= this.t) this[this.t++] = 0;
			    ++this[w];
			  }
			}

			// A "null" reducer
			function NullExp() {}
			function nNop(x) { return x; }
			function nMulTo(x,y,r) { x.multiplyTo(y,r); }
			function nSqrTo(x,r) { x.squareTo(r); }

			NullExp.prototype.convert = nNop;
			NullExp.prototype.revert = nNop;
			NullExp.prototype.mulTo = nMulTo;
			NullExp.prototype.sqrTo = nSqrTo;

			// (public) this^e
			function bnPow(e) { return this.exp(e,new NullExp()); }

			// (protected) r = lower n words of "this * a", a.t <= n
			// "this" should be the larger one if appropriate.
			function bnpMultiplyLowerTo(a,n,r) {
			  var i = Math.min(this.t+a.t,n);
			  r.s = 0; // assumes a,this >= 0
			  r.t = i;
			  while(i > 0) r[--i] = 0;
			  var j;
			  for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);
			  for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);
			  r.clamp();
			}

			// (protected) r = "this * a" without lower n words, n > 0
			// "this" should be the larger one if appropriate.
			function bnpMultiplyUpperTo(a,n,r) {
			  --n;
			  var i = r.t = this.t+a.t-n;
			  r.s = 0; // assumes a,this >= 0
			  while(--i >= 0) r[i] = 0;
			  for(i = Math.max(n-this.t,0); i < a.t; ++i)
			    r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);
			  r.clamp();
			  r.drShiftTo(1,r);
			}

			// Barrett modular reduction
			function Barrett(m) {
			  // setup Barrett
			  this.r2 = nbi();
			  this.q3 = nbi();
			  BigInteger.ONE.dlShiftTo(2*m.t,this.r2);
			  this.mu = this.r2.divide(m);
			  this.m = m;
			}

			function barrettConvert(x) {
			  if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);
			  else if(x.compareTo(this.m) < 0) return x;
			  else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }
			}

			function barrettRevert(x) { return x; }

			// x = x mod m (HAC 14.42)
			function barrettReduce(x) {
			  var self = this;
			  x.drShiftTo(self.m.t-1,self.r2);
			  if(x.t > self.m.t+1) { x.t = self.m.t+1; x.clamp(); }
			  self.mu.multiplyUpperTo(self.r2,self.m.t+1,self.q3);
			  self.m.multiplyLowerTo(self.q3,self.m.t+1,self.r2);
			  while(x.compareTo(self.r2) < 0) x.dAddOffset(1,self.m.t+1);
			  x.subTo(self.r2,x);
			  while(x.compareTo(self.m) >= 0) x.subTo(self.m,x);
			}

			// r = x^2 mod m; x != r
			function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

			// r = x*y mod m; x,y != r
			function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

			Barrett.prototype.convert = barrettConvert;
			Barrett.prototype.revert = barrettRevert;
			Barrett.prototype.reduce = barrettReduce;
			Barrett.prototype.mulTo = barrettMulTo;
			Barrett.prototype.sqrTo = barrettSqrTo;

			// (public) this^e % m (HAC 14.85)
			function bnModPow(e,m) {
			  var i = e.bitLength(), k, r = nbv(1), z;
			  if(i <= 0) return r;
			  else if(i < 18) k = 1;
			  else if(i < 48) k = 3;
			  else if(i < 144) k = 4;
			  else if(i < 768) k = 5;
			  else k = 6;
			  if(i < 8)
			    z = new Classic(m);
			  else if(m.isEven())
			    z = new Barrett(m);
			  else
			    z = new Montgomery(m);

			  // precomputation
			  var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;
			  g[1] = z.convert(this);
			  if(k > 1) {
			    var g2 = nbi();
			    z.sqrTo(g[1],g2);
			    while(n <= km) {
			      g[n] = nbi();
			      z.mulTo(g2,g[n-2],g[n]);
			      n += 2;
			    }
			  }

			  var j = e.t-1, w, is1 = true, r2 = nbi(), t;
			  i = nbits(e[j])-1;
			  while(j >= 0) {
			    if(i >= k1) w = (e[j]>>(i-k1))&km;
			    else {
			      w = (e[j]&((1<<(i+1))-1))<<(k1-i);
			      if(j > 0) w |= e[j-1]>>(this.DB+i-k1);
			    }

			    n = k;
			    while((w&1) == 0) { w >>= 1; --n; }
			    if((i -= n) < 0) { i += this.DB; --j; }
			    if(is1) {	// ret == 1, don't bother squaring or multiplying it
			      g[w].copyTo(r);
			      is1 = false;
			    }
			    else {
			      while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }
			      if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }
			      z.mulTo(r2,g[w],r);
			    }

			    while(j >= 0 && (e[j]&(1<<i)) == 0) {
			      z.sqrTo(r,r2); t = r; r = r2; r2 = t;
			      if(--i < 0) { i = this.DB-1; --j; }
			    }
			  }
			  return z.revert(r);
			}

			// (public) gcd(this,a) (HAC 14.54)
			function bnGCD(a) {
			  var x = (this.s<0)?this.negate():this.clone();
			  var y = (a.s<0)?a.negate():a.clone();
			  if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }
			  var i = x.getLowestSetBit(), g = y.getLowestSetBit();
			  if(g < 0) return x;
			  if(i < g) g = i;
			  if(g > 0) {
			    x.rShiftTo(g,x);
			    y.rShiftTo(g,y);
			  }
			  while(x.signum() > 0) {
			    if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);
			    if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);
			    if(x.compareTo(y) >= 0) {
			      x.subTo(y,x);
			      x.rShiftTo(1,x);
			    }
			    else {
			      y.subTo(x,y);
			      y.rShiftTo(1,y);
			    }
			  }
			  if(g > 0) y.lShiftTo(g,y);
			  return y;
			}

			// (protected) this % n, n < 2^26
			function bnpModInt(n) {
			  if(n <= 0) return 0;
			  var d = this.DV%n, r = (this.s<0)?n-1:0;
			  if(this.t > 0)
			    if(d == 0) r = this[0]%n;
			    else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;
			  return r;
			}

			// (public) 1/this % m (HAC 14.61)
			function bnModInverse(m) {
			  var ac = m.isEven();
			  if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;
			  var u = m.clone(), v = this.clone();
			  var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
			  while(u.signum() != 0) {
			    while(u.isEven()) {
			      u.rShiftTo(1,u);
			      if(ac) {
			        if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }
			        a.rShiftTo(1,a);
			      }
			      else if(!b.isEven()) b.subTo(m,b);
			      b.rShiftTo(1,b);
			    }
			    while(v.isEven()) {
			      v.rShiftTo(1,v);
			      if(ac) {
			        if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }
			        c.rShiftTo(1,c);
			      }
			      else if(!d.isEven()) d.subTo(m,d);
			      d.rShiftTo(1,d);
			    }
			    if(u.compareTo(v) >= 0) {
			      u.subTo(v,u);
			      if(ac) a.subTo(c,a);
			      b.subTo(d,b);
			    }
			    else {
			      v.subTo(u,v);
			      if(ac) c.subTo(a,c);
			      d.subTo(b,d);
			    }
			  }
			  if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
			  if(d.compareTo(m) >= 0) return d.subtract(m);
			  if(d.signum() < 0) d.addTo(m,d); else return d;
			  if(d.signum() < 0) return d.add(m); else return d;
			}

			// protected
			proto.chunkSize = bnpChunkSize;
			proto.toRadix = bnpToRadix;
			proto.fromRadix = bnpFromRadix;
			proto.fromNumber = bnpFromNumber;
			proto.bitwiseTo = bnpBitwiseTo;
			proto.changeBit = bnpChangeBit;
			proto.addTo = bnpAddTo;
			proto.dMultiply = bnpDMultiply;
			proto.dAddOffset = bnpDAddOffset;
			proto.multiplyLowerTo = bnpMultiplyLowerTo;
			proto.multiplyUpperTo = bnpMultiplyUpperTo;
			proto.modInt = bnpModInt;

			// public
			proto.clone = bnClone;
			proto.intValue = bnIntValue;
			proto.byteValue = bnByteValue;
			proto.shortValue = bnShortValue;
			proto.signum = bnSigNum;
			proto.toByteArray = bnToByteArray;
			proto.equals = bnEquals;
			proto.min = bnMin;
			proto.max = bnMax;
			proto.and = bnAnd;
			proto.or = bnOr;
			proto.xor = bnXor;
			proto.andNot = bnAndNot;
			proto.not = bnNot;
			proto.shiftLeft = bnShiftLeft;
			proto.shiftRight = bnShiftRight;
			proto.getLowestSetBit = bnGetLowestSetBit;
			proto.bitCount = bnBitCount;
			proto.testBit = bnTestBit;
			proto.setBit = bnSetBit;
			proto.clearBit = bnClearBit;
			proto.flipBit = bnFlipBit;
			proto.add = bnAdd;
			proto.subtract = bnSubtract;
			proto.multiply = bnMultiply;
			proto.divide = bnDivide;
			proto.remainder = bnRemainder;
			proto.divideAndRemainder = bnDivideAndRemainder;
			proto.modPow = bnModPow;
			proto.modInverse = bnModInverse;
			proto.pow = bnPow;
			proto.gcd = bnGCD;

			// JSBN-specific extension
			proto.square = bnSquare;

			// BigInteger interfaces not implemented in jsbn:

			// BigInteger(int signum, byte[] magnitude)
			// double doubleValue()
			// float floatValue()
			// int hashCode()
			// long longValue()
			// static BigInteger valueOf(long val)

			// "constants"
			BigInteger.ZERO = nbv(0);
			BigInteger.ONE = nbv(1);
			BigInteger.valueOf = nbv;


			/// bitcoinjs addons

			/**
			 * Turns a byte array into a big integer.
			 *
			 * This function will interpret a byte array as a big integer in big
			 * endian notation and ignore leading zeros.
			 */
			BigInteger.fromByteArrayUnsigned = function(ba) {

			  if (!ba.length) {
			    return new BigInteger.valueOf(0);
			  } else if (ba[0] & 0x80) {
			    // Prepend a zero so the BigInteger class doesn't mistake this
			    // for a negative integer.
			    return new BigInteger([0].concat(ba));
			  } else {
			    return new BigInteger(ba);
			  }
			};

			/**
			 * Parse a signed big integer byte representation.
			 *
			 * For details on the format please see BigInteger.toByteArraySigned.
			 */
			BigInteger.fromByteArraySigned = function(ba) {
			  // Check for negative value
			  if (ba[0] & 0x80) {
			    // Remove sign bit
			    ba[0] &= 0x7f;

			    return BigInteger.fromByteArrayUnsigned(ba).negate();
			  } else {
			    return BigInteger.fromByteArrayUnsigned(ba);
			  }
			};

			/**
			 * Returns a byte array representation of the big integer.
			 *
			 * This returns the absolute of the contained value in big endian
			 * form. A value of zero results in an empty array.
			 */
			BigInteger.prototype.toByteArrayUnsigned = function() {
			    var ba = this.abs().toByteArray();

			    // Empty array, nothing to do
			    if (!ba.length) {
			        return ba;
			    }

			    // remove leading 0
			    if (ba[0] === 0) {
			        ba = ba.slice(1);
			    }

			    // all values must be positive
			    for (var i=0 ; i<ba.length ; ++i) {
			      ba[i] = (ba[i] < 0) ? ba[i] + 256 : ba[i];
			    }

			    return ba;
			};

			/*
			 * Converts big integer to signed byte representation.
			 *
			 * The format for this value uses the most significant bit as a sign
			 * bit. If the most significant bit is already occupied by the
			 * absolute value, an extra byte is prepended and the sign bit is set
			 * there.
			 *
			 * Examples:
			 *
			 *      0 =>     0x00
			 *      1 =>     0x01
			 *     -1 =>     0x81
			 *    127 =>     0x7f
			 *   -127 =>     0xff
			 *    128 =>   0x0080
			 *   -128 =>   0x8080
			 *    255 =>   0x00ff
			 *   -255 =>   0x80ff
			 *  16300 =>   0x3fac
			 * -16300 =>   0xbfac
			 *  62300 => 0x00f35c
			 * -62300 => 0x80f35c
			*/
			BigInteger.prototype.toByteArraySigned = function() {
			  var val = this.toByteArrayUnsigned();
			  var neg = this.s < 0;

			  // if the first bit is set, we always unshift
			  // either unshift 0x80 or 0x00
			  if (val[0] & 0x80) {
			    val.unshift((neg) ? 0x80 : 0x00);
			  }
			  // if the first bit isn't set, set it if negative
			  else if (neg) {
			    val[0] |= 0x80;
			  }

			  return val;
			};


			/**
			 * string_math.js
			 *
			 * Standard math functions using standard arithmetic, for precision beyond normal JavaScript floating point.
			 *
			 * @package StringMath
			 * @subpackage StringMath
			 * @author Nicholas Tieman
			 */
			var StringMath = new function() {
				/**
				 * @var number Default number of decimal places to calculate for operations that accept this parameter.
				 */
				this.defaultPrecision = 40;
				/**
				 * Finds the absolute value of a number.
				 *
				 * @param string number Number.
				 * @return string Absolute value.
				 */
				this.abs = function(number) {
					if(number.charAt(0) === "-1") {
						return number.substr(1);
					} else {
						return number;
					}
				}
				/**
				 * Adds two numbers.
				 *
				 * @param string a First number.
				 * @param string b Second number.
				 * @return string Sum.
				 */
				this.add = function(a, b) {
					var aNegative = (a.charAt(0) === "-");
					var bNegative = (b.charAt(0) === "-"); 
					
					if(aNegative && bNegative) {
						return "-" + StringMath.add(a.substr(1), b.substr(1));
					} else if(aNegative && !bNegative) {
						return StringMath.subtract(b, a.substr(1));
					} else if(!aNegative && bNegative) {
						return StringMath.subtract(a, b.substr(1));
					}
					
					var paddedValues = padEqual(a, b);
					
					a = paddedValues.a;
					b = paddedValues.b;
				
					var sum = "";
					var carry = 0;
					var index = paddedValues.length;
					
					while(index--) {
						if(a.charAt(index) === ".") {
							sum = "." + sum;
							
							continue;
						}
						
						var digit = parseInt(a.charAt(index), 10) + parseInt(b.charAt(index), 10) + carry;
						
						if(digit > 9) {
							digit -= 10;
							carry = 1;
						} else {
							carry = 0;
						}
						
						sum = digit.toString() + sum;
					}
					
					if(carry === 1) {
						sum = carry.toString() + sum;
					}
					
					sum = prettify(sum);
					
					return sum;
				}
				/**
				 * Rounds the number up to the nearest whole.
				 *
				 * @param string number Number to round.
				 * @return string Rounded number.
				 */
				this.ceil = function(number) {
					return StringMath.floor(StringMath.add(number, "1"));
				}
				/**
				 * Formats numbers for use with StringMath.
				 *
				 * @param number|string number Number to format.
				 * @return string Formatted number.
				 */
				this.clean = function(number) {
					if(typeof(number) !== "string") {
						number = number.toString();
					}
					
					number = scientificToLong(number);
					number = prettify(number);
					
					return number;
				}
				/**
				 * Compares two string numbers.
				 *
				 * @param string a First number.
				 * @param string b Second number.
				 * @return number 1 if a > b, 0 if a == b, -1 if a < b.
				 */
				this.compare = function(a, b) {
					a = prettify(a);
					b = prettify(b);
					
					if(a === b) {
						return 0;
					}
					
					var aNegative = (a.charAt(0) === "-");
					var bNegative = (b.charAt(0) === "-");
				
					if(!aNegative && bNegative) {
						return 1;
					} else if(aNegative && !bNegative) {
						return -1;
					} else if(aNegative && bNegative) {
						a = a.substr(1);
						b = b.substr(1);
						
						var sign = -1;
					} else {
						var sign = 1;
					}
				
					var paddedValues = padEqual(a, b);
					
					a = paddedValues.a;
					b = paddedValues.b;
					
					var length = paddedValues.length;
					
					for(var i = 0; i < length; i++) {
						if(a.charAt(i) === ".") {
							continue;
						}
						
						var aDigit = parseInt(a.charAt(i), 10);
						var bDigit = parseInt(b.charAt(i), 10);
						
						if(aDigit > bDigit) {
							return sign;
						} else if(aDigit < bDigit) {
							return sign * -1;
						}
					}
					
					return 0;
				}
				/**
				 * Divides two numbers.
				 *
				 * @param string a First number.
				 * @param string b Second number.
				 * @param number precision Maximum number of decimal places to calculate (optional).
				 * @return string Quotient.
				 */
				this.divide = function(a, b, precision) {
					if(StringMath.equal(a, "0")) {
						return "0";
					} else if(StringMath.equal(b, "0")) {
						return "NaN";
					}
					
					var aNegative = (a.charAt(0) === "-");
					var bNegative = (b.charAt(0) === "-");
					
					if(aNegative && bNegative) {
						return StringMath.divide(a.substr(1), b.substr(1), precision);
					} else if(aNegative && !bNegative) {
						return "-" + StringMath.divide(a.substr(1), b, precision);
					} else if(!aNegative && bNegative) {
						return "-" + StringMath.divide(a, b.substr(1), precision);
					}
					
					if(typeof(precision) === "undefined") {
						precision = StringMath.defaultPrecision;
					}
					
					a = prettify(a);
					b = prettify(b);
					
					while(decimalIndex(b) !== b.length) {
						a = shiftDecimal(a, 1);
						b = shiftDecimal(b, 1);
					}
					
					var subdividend = "";
					var desiredLength = bLength;
					var aLength = a.length;
					var bLength = b.length;
					var aDecimalIndex = decimalIndex(a);
					var quotient = "";
					var index = 0;
					
					do {
						if(index >= aLength && index !== aDecimalIndex && subdividend.charAt(0) !== "0") {
							subdividend += "0";
						} else if(a.charAt(index) !== ".") {
							subdividend += a.charAt(index);
						}

						if(StringMath.greaterOrEqual(subdividend, b)) {
							var times = "1";
							var product = b;
							
							while(StringMath.less(product, subdividend)) {
								times = StringMath.add(times, "1");
								product = StringMath.add(product, b);
							}
							
							if(StringMath.greater(product, subdividend)) {
								times = StringMath.subtract(times, "1");
								product = StringMath.subtract(product, b);
								subdividend = StringMath.subtract(subdividend, product);
							} else {
								subdividend = "";
							}
							
							quotient += times;
						} else if(index === aDecimalIndex || a.charAt(index) === ".") {
							quotient += ".";
						} else {
							quotient += "0";
						}
						
						index++;
					} while((!StringMath.equal(subdividend, "0") || index < aLength) && (index - aDecimalIndex) <= precision);
					
					quotient = prettify(quotient);
					
					return quotient;
				}
				/**
				 * Determines whether or not two string numbers are equal.
				 *
				 * @param string a First number.
				 * @param string b Second number.
				 * @return boolean Whether or not the values are equal.
				 */
				this.equal = function(a, b) {
					return prettify(a) === prettify(b);
				}
				/**
				 * Rounds the number down to the nearest whole.
				 * 
				 * @param string number Number to round.
				 * @return string Rounded number.
				 */
				this.floor = function(number) {
					return prettify(number.substr(0, decimalIndex(number)));
				}
				/**
				 * Determines whether or not the first number is greater than the second.
				 *
				 * @param string a First number.
				 * @param string b Second number.
				 * @return boolean Whether or not the first number is greater than the second.
				 */
				this.greater = function(a, b) {
					return StringMath.compare(a, b) === 1;
				}
				/**
				 * Determines whether or not the first number is greater than or equal to the second.
				 *
				 * @param string a First number.
				 * @param string b Second number.
				 * @return boolean Whether or not the first number is greater than the second.
				 */
				this.greaterOrEqual = function(a, b) {
					return StringMath.compare(a, b) !== -1;
				}
				/**
				 * Determines whether or not the first number is less than the second.
				 *
				 * @param string a First number.
				 * @param string b Second number.
				 * @return boolean Whether or not the first number is less than the second.
				 */
				this.less = function(a, b) {
					return StringMath.compare(a, b) === -1;
				}
				/**
				 * Determines whether or not the first number is less than or equal to the second.
				 *
				 * @param string a First number.
				 * @param string b Second number.
				 * @return boolean Whether or not the first number is less than the second.
				 */
				this.lessOrEqual = function(a, b) {
					return StringMath.compare(a, b) !== 1;
				}
				/**
				 * Returns the input with the greatest value.
				 *
				 * @param string num1, num2, ... Test numbers.
				 * @return string Greatest number.
				 */
				this.max = function() {
					var argumentsLength = arguments.length;
					
					if(argumentsLength === 0) {
						return undefined;
					}
					
					var max = arguments[0];
					
					for(var i = 1; i < argumentsLength; i++) {
						var argument = arguments[i];
						
						if(StringMath.greater(argument, max)) {
							max = argument;
						}
					}
					
					return max;
				}
				/**
				 * Returns the input with the lowest value.
				 *
				 * @param string num1, num2, ... Test numbers.
				 * @return string Greatest number.
				 */
				this.min = function() {
					var argumentsLength = arguments.length;
					
					if(argumentsLength === 0) {
						return undefined;
					}
					
					var min = arguments[0];
					
					for(var i = 1; i < argumentsLength; i++) {
						var argument = arguments[i];
						
						if(StringMath.less(argument, min)) {
							min = argument;
						}
					}
					
					return min;
				}
				/**
				 * Finds the modulo of two numbers.
				 *
				 * @param string a First number.
				 * @param string b Second number.
				 * @return string Modulus.
				 */
				this.modulo = function(a, b) {
					var times = StringMath.divide(a, b, 0);
					var quotient = StringMath.multiply(b, times);
					
					return StringMath.subtract(a, quotient);
				}
				/**
				 * Multiplies two numbers.
				 *
				 * @param string a First number.
				 * @param string b Second number.
				 * @return string Product.
				 */
				this.multiply = function(a, b) {
					var aNegative = (a.charAt(0) === "-");
					var bNegative = (b.charAt(0) === "-");
					
					if(aNegative && bNegative) {
						return StringMath.multiply(a.substr(1), b.substr(1));
					} else if(aNegative && !bNegative) {
						return "-" + StringMath.multiply(a.substr(1), b);
					} else if(!aNegative && bNegative) {
						return "-" + StringMath.multiply(a, b.substr(1));
					}
					
					var aLength = a.length;
					var bLength = b.length;
					
					var aDecimalIndex = decimalIndex(a);
					var bDecimalIndex = decimalIndex(b);
					
					var product = "0";
					
					for(var i = 0; i < aLength; i++) {
						if(a.charAt(i) === ".") {
							continue;
						}
						
						var aDigit = parseInt(a.charAt(i), 10);
						
						if(aDigit === 0) {
							continue;
						}
						
						var aPlace = (aDecimalIndex - 1) - i;
						
						if(aPlace < 0) {
							aPlace++;
						}
						
						for(var j = 0; j < bLength; j++) {
							if(b.charAt(j) === ".") {
								continue;
							}
						
							var bDigit = parseInt(b.charAt(j), 10);
						
							if(bDigit === 0) {
								continue;
							}
						
							var bPlace = (bDecimalIndex - 1) - j;
							
							if(bPlace < 0) {
								bPlace++;
							}
							
							var subProduct = (aDigit * bDigit).toString();
							var subProductPlace = aPlace + bPlace;

							if(subProductPlace > 0) {
								subProduct = subProduct + repeat("0", subProductPlace);
							} else if(subProductPlace === -1 && subProduct.length === 2) {
								subProduct = subProduct.charAt(0) + "." + subProduct.charAt(1);
							} else if(subProductPlace < 0) {
								subProduct = "0." + repeat("0", Math.abs(subProductPlace) - subProduct.length) + subProduct;
							}

							product = StringMath.add(product, subProduct);
						}
					}
					
					product = prettify(product);
					
					return product;
				}
				/**
				 * Calculates an exponent.
				 *
				 * @param string base Base number.
				 * @param string power Power to raise to.
				 * @param number precision Number of decimal points to calculate (optional).
				 */
				this.pow = function(base, power, precision) {
					if(power.charAt(0) === "-") {
						return StringMath.divide("1", StringMath.pow(base, power.substr(1), precision));
					}
					
					var root = "1";
					
					while(!StringMath.equal(power, StringMath.floor(power))) {
						root = shiftDecimal(root, 1);
						power = shiftDecimal(power, 1);
					}
					
					var exponent = "1";
					var times = power;
					
					while(StringMath.greater(times, "0")) {
						exponent = StringMath.multiply(exponent, base);
						times = StringMath.subtract(times, "1");
					}
					
					if(!StringMath.equal(root, "1")) {
						exponent = StringMath.root(exponent, root, precision);
					}
					
					return exponent;
				}
				/**
				 * Finds the given root of a number.
				 *
				 * @param string base Base number.
				 * @param string degree Desired root.
				 * @param number precision Number of digits to calculate (optional).
				 * @return string Calculated root.
				 */
				this.root = function(base, degree, precision) {
					if(base.charAt(0) === "-") {
			 			return StringMath.root(base.substr(1), degree, precision) + "i";
					}
					
					if(typeof(precision) === "undefined") {
						precision = StringMath.defaultPrecision;
					}
					
					var root = "-1";
					var product;
					
					do {
						root = StringMath.add(root, "1");
						product = "1";
						
						var times = degree;
						
						while(StringMath.greater(times, "0")) {
							product = StringMath.multiply(product, root);
							times = StringMath.subtract(times, "1");
						}
					} while(StringMath.less(product, base));
					
					if(StringMath.equal(product, base)) {
						return root;
					}
					
					root = StringMath.subtract(root, "1") + ".";
					
					var digits = 0;
					var equal;
					
					do {
						var digit = "-1";
						
						do {
							product = "1";
							digit = StringMath.add(digit, "1");
							
							var testRoot = root + digit;
							var times = degree;
						
							while(StringMath.greater(times, "0")) {
								product = StringMath.multiply(product, testRoot);
								times = StringMath.subtract(times, "1");
							}
						} while(StringMath.less(product, base));
						
						equal = StringMath.equal(product, base);
						
						if(!equal) {
							digit = StringMath.subtract(digit, "1");
							root += digit;
						}
						
						digits++;
					} while(!equal && digits < precision);
					
					return root;
				}
				/**
				 * Rounds a number to the nearest whole.
				 *
				 * @param string number Number to round.
				 * @return string Rounded number.
				 */
				this.round = function(number) {
					var base = StringMath.floor(number) + ".5";
					
					if(StringMath.less(number, base)) {
						return StringMath.ceil(number);
					} else {
						return StringMath.floor(number);
					}
				}
				/**
				 * Finds the square root of a given number.
				 *
				 * @param string base Base number.
				 * @param number precision Number of decimal places to calculate (optional).
				 * @return string Square root.
				 */
				this.sqrt = function(base, precision) {
					return StringMath.root(base, "2", precision);
				}
				/**
				 * Subtracts one number from another.
				 *
				 * @param string a First number.
				 * @param string b Second number.
				 * @return number Difference.
				 */
				this.subtract = function(a, b) {
					var aNegative = (a.charAt(0) === "-");
					var bNegative = (b.charAt(0) === "-");
					
					if(bNegative) {
						return StringMath.add(a, b.substr(1));
					} else if(aNegative) {
						return "-" + StringMath.add(a.substr(1), b);
					} else if(StringMath.compare(a, b) === -1) {
						return "-" + StringMath.subtract(b, a);
					}
					
					var paddedValues = padEqual(a, b);
					
					a = paddedValues.a;
					b = paddedValues.b;
					
					var index = paddedValues.length;
					var carry = 0;
					var difference = "";
					
					while(index--) {
						if(a.charAt(index) === ".") {
							difference = "." + difference;
							
							continue;
						}
						
						var aDigit = parseInt(a.charAt(index), 10);
						var bDigit = parseInt(b.charAt(index), 10);
						var digit = aDigit - bDigit - carry;
						
						if(digit < 0) {
							digit += 10;
							carry = 1;
						} else {
							carry = 0;
						}
						
						difference = digit.toString() + difference;
					}
					
					difference = prettify(difference);
					
					return difference;
				}
				/**
				 * Finds the index of the decimal point in a number string.
				 *
				 * @param string number Number.
				 * @return number Decimal point index.
				 */
				var decimalIndex = function(number) {
					var index = number.indexOf(".");
					
					if(index === -1) {
						return number.length;
					} else {
						return index;
					}
				}
				/**
				 * Changes positive numbers to negative, and negative to positive.
				 *
				 * @param string number Number to flip.
				 * @return string Flipped number.
				 */
				var flipSign = function(number) {
					if(number.charAt(0) === "-") {
						return number.substr(1);
					} else {
						return "-" + number;
					}
				}
				/**
				 * Inserts a string into another string at the given position.
				 *
				 * @param string destination String to modify.
				 * @param string insert String to insert.
				 * @param number position Index at which to insert.
				 */
				var insert = function(destination, insert, position) {
					if(position <= 0) {
						return insert + destination;
					} else {
						return destination.substr(0, position) + insert + destination.substr(position);
					}
				}
				/**
				 * Pads two values with zeroes so that they are the same length and their decimal points are in the same position.
				 *
				 * @param string a First number.
				 * @param string b Second number.
				 * @return object Padded values, a and b.
				 */
				var padEqual = function(a, b) {
					var aDecimalIndex = decimalIndex(a);
					var bDecimalIndex = decimalIndex(b);
					
					if(aDecimalIndex > bDecimalIndex) {
						var maxPlace = aDecimalIndex;
					} else {
						var maxPlace = bDecimalIndex;
					}
					
					var aLength = a.length;
					var bLength = b.length;
					
					var aMinPlace = aDecimalIndex - aLength;
					var bMinPlace = bDecimalIndex - bLength;
					
					if(aMinPlace < bMinPlace) {
						var minPlace = aMinPlace;
					} else {
						var minPlace = bMinPlace;
					}
					
					a = repeat("0", maxPlace - aDecimalIndex) + a + repeat("0", aMinPlace - minPlace);
					b = repeat("0", maxPlace - bDecimalIndex) + b + repeat("0", bMinPlace - minPlace);
					
					a = a.substr(0, maxPlace) + "." + a.substr(maxPlace + 1);
					b = b.substr(0, maxPlace) + "." + b.substr(maxPlace + 1);
					
					return { "a": a, "b": b, "length": a.length };
				}
				/**
				 * Trims leading and trailing zeroes and unnecessary decimal points, and adds leading zero to appropriate decimals.
				 *
				 * @param number Number to format.
				 * @return Formatted number.
				 */
				var prettify = function(number) {
					number = trimZeroes(number);
					number = trimDecimal(number);
					
					if(number.charAt(0) === ".") {
						number = "0" + number;
					}
					
					if(number === "-0") {
						number = "0";
					}
					
					if(number === "") {
						number = "0";
					}
					
					return number;
				}
				/**
				 * Repeats a string a given number of times.
				 *
				 * @param string content String to repeat.
				 * @param number times Number of times to repeat.
				 * @return string Repeated string.
				 */
				var repeat = function(content, times) {
					var repeated = "";
					
					while(times-- > 0) {
						repeated += content;
					}
					
					return repeated;
				}
				/**
				 * Shifts the decimal point by the given amount.
				 *
				 * @param string number Number to alter.
				 * @param number shift Number of places to shift. Negative for left, positive for right.
				 * @return string Shifted number.
				 */
				var shiftDecimal = function(number, shift) {
					var index = decimalIndex(number);
					var goal = index + shift;
					var number = number.replace(".", "");
					
					if(goal === 0) {
						return "0." + number;
					} else if(goal < 0) {
						return "0." + repeat("0", goal * -1) + number;
					} else if(goal > number.length) {
						return number + repeat("0", goal - number.length);
					} else {
						return insert(number, ".", goal);
					}
				}
				/**
				 * Converts JavaScript scientific notation to standard longform notation.
				 *
				 * @param string number Number to format.
				 * @return string Formatted number.
				 */
				var scientificToLong = function(number) {
					var match = /([0-9.]+)e([+|-])(\d+)/.exec(number);
					
					if(match) {
						var base = match[1];
						var sign = match[2];
						var power = parseInt(match[3], 10);
						var baseDecimalIndex = decimalIndex(base);
						
						base = base.replace(".", "");
						
						if(sign === "+") {
							number = base + repeat("0", power);
							baseDecimalIndex += power;
						} else {
							number = repeat("0", power - 1) + base;
							baseDecimalIndex -= power;
						}
						
						number = insert(number, ".", baseDecimalIndex);
						number = prettify(number);
					}
					
					return number;
				}
				/**
				 * Removes unncessary decimal points.
				 *
				 * @param number Number to trim.
				 * @return string Trimmed number.
				 */
				var trimDecimal = function(number) {
					if(number.indexOf(".") === number.length - 1) {
						return number.substr(0, number.length - 1);
					} else {
						return number;
					}
				}
				/**
				 * Trims unnecessary leading and trailing zeroes.
				 *
				 * @param string number Number to trim.
				 * @return string Trimmed number.
				 */
				var trimZeroes = function(number) {
					number = number.replace(/^(-)?(0(?!\.))+/, "$1");
					number = number.replace(/(\.[1-9]*)0+$/, "$1");
					
					return number;
				}
			}();

			/*!
			* Basic Javascript Elliptic Curve implementation
			* Ported loosely from BouncyCastle's Java EC code
			* Only Fp curves implemented for now
			* 
			* Copyright Tom Wu, bitaddress.org  BSD License.
			* http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE
			*/
			(function () {

				// Constructor function of Global EllipticCurve object
				var ec = window.EllipticCurve = function () { };


				// ----------------
				// ECFieldElementFp constructor
				// q instanceof BigInteger
				// x instanceof BigInteger
				ec.FieldElementFp = function (q, x) {
					this.x = x;
					// TODO if(x.compareTo(q) >= 0) error
					this.q = q;
				};

				ec.FieldElementFp.prototype.equals = function (other) {
					if (other == this) return true;
					return (this.q.equals(other.q) && this.x.equals(other.x));
				};

				ec.FieldElementFp.prototype.toBigInteger = function () {
					return this.x;
				};

				ec.FieldElementFp.prototype.negate = function () {
					return new ec.FieldElementFp(this.q, this.x.negate().mod(this.q));
				};

				ec.FieldElementFp.prototype.add = function (b) {
					return new ec.FieldElementFp(this.q, this.x.add(b.toBigInteger()).mod(this.q));
				};

				ec.FieldElementFp.prototype.subtract = function (b) {
					return new ec.FieldElementFp(this.q, this.x.subtract(b.toBigInteger()).mod(this.q));
				};

				ec.FieldElementFp.prototype.multiply = function (b) {
					return new ec.FieldElementFp(this.q, this.x.multiply(b.toBigInteger()).mod(this.q));
				};

				ec.FieldElementFp.prototype.square = function () {
					return new ec.FieldElementFp(this.q, this.x.square().mod(this.q));
				};

				ec.FieldElementFp.prototype.divide = function (b) {
					return new ec.FieldElementFp(this.q, this.x.multiply(b.toBigInteger().modInverse(this.q)).mod(this.q));
				};

				ec.FieldElementFp.prototype.getByteLength = function () {
					return Math.floor((this.toBigInteger().bitLength() + 7) / 8);
				};

				// D.1.4 91
				/**
				* return a sqrt root - the routine verifies that the calculation
				* returns the right value - if none exists it returns null.
				* 
				* Copyright (c) 2000 - 2011 The Legion Of The Bouncy Castle (http://www.bouncycastle.org)
				* Ported to JavaScript by bitaddress.org
				*/
				ec.FieldElementFp.prototype.sqrt = function () {
					if (!this.q.testBit(0)) throw new Error("even value of q");

					// p mod 4 == 3
					if (this.q.testBit(1)) {
						// z = g^(u+1) + p, p = 4u + 3
						var z = new ec.FieldElementFp(this.q, this.x.modPow(this.q.shiftRight(2).add(BigInteger.ONE), this.q));
						return z.square().equals(this) ? z : null;
					}

					// p mod 4 == 1
					var qMinusOne = this.q.subtract(BigInteger.ONE);
					var legendreExponent = qMinusOne.shiftRight(1);
					if (!(this.x.modPow(legendreExponent, this.q).equals(BigInteger.ONE))) return null;
					var u = qMinusOne.shiftRight(2);
					var k = u.shiftLeft(1).add(BigInteger.ONE);
					var Q = this.x;
					var fourQ = Q.shiftLeft(2).mod(this.q);
					var U, V;

					do {
						var rand = new SecureRandom();
						var P;
						do {
							P = new BigInteger(this.q.bitLength(), rand);
						}
						while (P.compareTo(this.q) >= 0 || !(P.multiply(P).subtract(fourQ).modPow(legendreExponent, this.q).equals(qMinusOne)));

						var result = ec.FieldElementFp.fastLucasSequence(this.q, P, Q, k);

						U = result[0];
						V = result[1];
						if (V.multiply(V).mod(this.q).equals(fourQ)) {
							// Integer division by 2, mod q
							if (V.testBit(0)) {
								V = V.add(this.q);
							}
							V = V.shiftRight(1);
							return new ec.FieldElementFp(this.q, V);
						}
					}
					while (U.equals(BigInteger.ONE) || U.equals(qMinusOne));

					return null;
				};

				/*
				* Copyright (c) 2000 - 2011 The Legion Of The Bouncy Castle (http://www.bouncycastle.org)
				* Ported to JavaScript by bitaddress.org
				*/
				ec.FieldElementFp.fastLucasSequence = function (p, P, Q, k) {
					// TODO Research and apply "common-multiplicand multiplication here"

					var n = k.bitLength();
					var s = k.getLowestSetBit();
					var Uh = BigInteger.ONE;
					var Vl = BigInteger.TWO;
					var Vh = P;
					var Ql = BigInteger.ONE;
					var Qh = BigInteger.ONE;

					for (var j = n - 1; j >= s + 1; --j) {
						Ql = Ql.multiply(Qh).mod(p);
						if (k.testBit(j)) {
							Qh = Ql.multiply(Q).mod(p);
							Uh = Uh.multiply(Vh).mod(p);
							Vl = Vh.multiply(Vl).subtract(P.multiply(Ql)).mod(p);
							Vh = Vh.multiply(Vh).subtract(Qh.shiftLeft(1)).mod(p);
						}
						else {
							Qh = Ql;
							Uh = Uh.multiply(Vl).subtract(Ql).mod(p);
							Vh = Vh.multiply(Vl).subtract(P.multiply(Ql)).mod(p);
							Vl = Vl.multiply(Vl).subtract(Ql.shiftLeft(1)).mod(p);
						}
					}

					Ql = Ql.multiply(Qh).mod(p);
					Qh = Ql.multiply(Q).mod(p);
					Uh = Uh.multiply(Vl).subtract(Ql).mod(p);
					Vl = Vh.multiply(Vl).subtract(P.multiply(Ql)).mod(p);
					Ql = Ql.multiply(Qh).mod(p);

					for (var j = 1; j <= s; ++j) {
						Uh = Uh.multiply(Vl).mod(p);
						Vl = Vl.multiply(Vl).subtract(Ql.shiftLeft(1)).mod(p);
						Ql = Ql.multiply(Ql).mod(p);
					}

					return [Uh, Vl];
				};

				// ----------------
				// ECPointFp constructor
				ec.PointFp = function (curve, x, y, z, compressed) {
					this.curve = curve;
					this.x = x;
					this.y = y;
					// Projective coordinates: either zinv == null or z * zinv == 1
					// z and zinv are just BigIntegers, not fieldElements
					if (z == null) {
						this.z = BigInteger.ONE;
					}
					else {
						this.z = z;
					}
					this.zinv = null;
					// compression flag
					this.compressed = !!compressed;
				};

				ec.PointFp.prototype.getX = function () {
					if (this.zinv == null) {
						this.zinv = this.z.modInverse(this.curve.q);
					}
					var r = this.x.toBigInteger().multiply(this.zinv);
					this.curve.reduce(r);
					return this.curve.fromBigInteger(r);
				};

				ec.PointFp.prototype.getY = function () {
					if (this.zinv == null) {
						this.zinv = this.z.modInverse(this.curve.q);
					}
					var r = this.y.toBigInteger().multiply(this.zinv);
					this.curve.reduce(r);
					return this.curve.fromBigInteger(r);
				};

				ec.PointFp.prototype.equals = function (other) {
					if (other == this) return true;
					if (this.isInfinity()) return other.isInfinity();
					if (other.isInfinity()) return this.isInfinity();
					var u, v;
					// u = Y2 * Z1 - Y1 * Z2
					u = other.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(other.z)).mod(this.curve.q);
					if (!u.equals(BigInteger.ZERO)) return false;
					// v = X2 * Z1 - X1 * Z2
					v = other.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(other.z)).mod(this.curve.q);
					return v.equals(BigInteger.ZERO);
				};

				ec.PointFp.prototype.isInfinity = function () {
					if ((this.x == null) && (this.y == null)) return true;
					return this.z.equals(BigInteger.ZERO) && !this.y.toBigInteger().equals(BigInteger.ZERO);
				};

				ec.PointFp.prototype.negate = function () {
					return new ec.PointFp(this.curve, this.x, this.y.negate(), this.z);
				};

				ec.PointFp.prototype.add = function (b) {
					if (this.isInfinity()) return b;
					if (b.isInfinity()) return this;

					// u = Y2 * Z1 - Y1 * Z2
					var u = b.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(b.z)).mod(this.curve.q);
					// v = X2 * Z1 - X1 * Z2
					var v = b.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(b.z)).mod(this.curve.q);


					if (BigInteger.ZERO.equals(v)) {
						if (BigInteger.ZERO.equals(u)) {
							return this.twice(); // this == b, so double
						}
						return this.curve.getInfinity(); // this = -b, so infinity
					}

					var THREE = new BigInteger("3");
					var x1 = this.x.toBigInteger();
					var y1 = this.y.toBigInteger();
					var x2 = b.x.toBigInteger();
					var y2 = b.y.toBigInteger();

					var v2 = v.square();
					var v3 = v2.multiply(v);
					var x1v2 = x1.multiply(v2);
					var zu2 = u.square().multiply(this.z);

					// x3 = v * (z2 * (z1 * u^2 - 2 * x1 * v^2) - v^3)
					var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.q);
					// y3 = z2 * (3 * x1 * u * v^2 - y1 * v^3 - z1 * u^3) + u * v^3
					var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.q);
					// z3 = v^3 * z1 * z2
					var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.q);

					return new ec.PointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
				};

				ec.PointFp.prototype.twice = function () {
					if (this.isInfinity()) return this;
					if (this.y.toBigInteger().signum() == 0) return this.curve.getInfinity();

					// TODO: optimized handling of constants
					var THREE = new BigInteger("3");
					var x1 = this.x.toBigInteger();
					var y1 = this.y.toBigInteger();

					var y1z1 = y1.multiply(this.z);
					var y1sqz1 = y1z1.multiply(y1).mod(this.curve.q);
					var a = this.curve.a.toBigInteger();

					// w = 3 * x1^2 + a * z1^2
					var w = x1.square().multiply(THREE);
					if (!BigInteger.ZERO.equals(a)) {
						w = w.add(this.z.square().multiply(a));
					}
					w = w.mod(this.curve.q);
					//this.curve.reduce(w);
					// x3 = 2 * y1 * z1 * (w^2 - 8 * x1 * y1^2 * z1)
					var x3 = w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.q);
					// y3 = 4 * y1^2 * z1 * (3 * w * x1 - 2 * y1^2 * z1) - w^3
					var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.square().multiply(w)).mod(this.curve.q);
					// z3 = 8 * (y1 * z1)^3
					var z3 = y1z1.square().multiply(y1z1).shiftLeft(3).mod(this.curve.q);

					return new ec.PointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
				};

				// Simple NAF (Non-Adjacent Form) multiplication algorithm
				// TODO: modularize the multiplication algorithm
				ec.PointFp.prototype.multiply = function (k) {
					if (this.isInfinity()) return this;
					if (k.signum() == 0) return this.curve.getInfinity();

					var e = k;
					var h = e.multiply(new BigInteger("3"));

					var neg = this.negate();
					var R = this;

					var i;
					for (i = h.bitLength() - 2; i > 0; --i) {
						R = R.twice();

						var hBit = h.testBit(i);
						var eBit = e.testBit(i);

						if (hBit != eBit) {
							R = R.add(hBit ? this : neg);
						}
					}

					return R;
				};

				// Compute this*j + x*k (simultaneous multiplication)
				ec.PointFp.prototype.multiplyTwo = function (j, x, k) {
					var i;
					if (j.bitLength() > k.bitLength())
						i = j.bitLength() - 1;
					else
						i = k.bitLength() - 1;

					var R = this.curve.getInfinity();
					var both = this.add(x);
					while (i >= 0) {
						R = R.twice();
						if (j.testBit(i)) {
							if (k.testBit(i)) {
								R = R.add(both);
							}
							else {
								R = R.add(this);
							}
						}
						else {
							if (k.testBit(i)) {
								R = R.add(x);
							}
						}
						--i;
					}

					return R;
				};

				// patched by bitaddress.org and Casascius for use with Bitcoin.ECKey
				// patched by coretechs to support compressed public keys
				ec.PointFp.prototype.getEncoded = function (compressed) {
					var x = this.getX().toBigInteger();
					var y = this.getY().toBigInteger();
					var len = 32; // integerToBytes will zero pad if integer is less than 32 bytes. 32 bytes length is required by the Bitcoin protocol.
					var enc = ec.integerToBytes(x, len);

					// when compressed prepend byte depending if y point is even or odd 
					if (compressed) {
						if (y.isEven()) {
							enc.unshift(0x02);
						}
						else {
							enc.unshift(0x03);
						}
					}
					else {
						enc.unshift(0x04);
						enc = enc.concat(ec.integerToBytes(y, len)); // uncompressed public key appends the bytes of the y point
					}
					return enc;
				};

				ec.PointFp.decodeFrom = function (curve, enc) {
					var type = enc[0];
					var dataLen = enc.length - 1;

					// Extract x and y as byte arrays
					var xBa = enc.slice(1, 1 + dataLen / 2);
					var yBa = enc.slice(1 + dataLen / 2, 1 + dataLen);

					// Prepend zero byte to prevent interpretation as negative integer
					xBa.unshift(0);
					yBa.unshift(0);

					// Convert to BigIntegers
					var x = new BigInteger(xBa);
					var y = new BigInteger(yBa);

					// Return point
					return new ec.PointFp(curve, curve.fromBigInteger(x), curve.fromBigInteger(y));
				};

				ec.PointFp.prototype.add2D = function (b) {
					if (this.isInfinity()) return b;
					if (b.isInfinity()) return this;

					if (this.x.equals(b.x)) {
						if (this.y.equals(b.y)) {
							// this = b, i.e. this must be doubled
							return this.twice();
						}
						// this = -b, i.e. the result is the point at infinity
						return this.curve.getInfinity();
					}

					var x_x = b.x.subtract(this.x);
					var y_y = b.y.subtract(this.y);
					var gamma = y_y.divide(x_x);

					var x3 = gamma.square().subtract(this.x).subtract(b.x);
					var y3 = gamma.multiply(this.x.subtract(x3)).subtract(this.y);

					return new ec.PointFp(this.curve, x3, y3);
				};

				ec.PointFp.prototype.twice2D = function () {
					if (this.isInfinity()) return this;
					if (this.y.toBigInteger().signum() == 0) {
						// if y1 == 0, then (x1, y1) == (x1, -y1)
						// and hence this = -this and thus 2(x1, y1) == infinity
						return this.curve.getInfinity();
					}

					var TWO = this.curve.fromBigInteger(BigInteger.valueOf(2));
					var THREE = this.curve.fromBigInteger(BigInteger.valueOf(3));
					var gamma = this.x.square().multiply(THREE).add(this.curve.a).divide(this.y.multiply(TWO));

					var x3 = gamma.square().subtract(this.x.multiply(TWO));
					var y3 = gamma.multiply(this.x.subtract(x3)).subtract(this.y);

					return new ec.PointFp(this.curve, x3, y3);
				};

				ec.PointFp.prototype.multiply2D = function (k) {
					if (this.isInfinity()) return this;
					if (k.signum() == 0) return this.curve.getInfinity();

					var e = k;
					var h = e.multiply(new BigInteger("3"));

					var neg = this.negate();
					var R = this;

					var i;
					for (i = h.bitLength() - 2; i > 0; --i) {
						R = R.twice();

						var hBit = h.testBit(i);
						var eBit = e.testBit(i);

						if (hBit != eBit) {
							R = R.add2D(hBit ? this : neg);
						}
					}

					return R;
				};

				ec.PointFp.prototype.isOnCurve = function () {
					var x = this.getX().toBigInteger();
					var y = this.getY().toBigInteger();
					var a = this.curve.getA().toBigInteger();
					var b = this.curve.getB().toBigInteger();
					var n = this.curve.getQ();
					var lhs = y.multiply(y).mod(n);
					var rhs = x.multiply(x).multiply(x).add(a.multiply(x)).add(b).mod(n);
					return lhs.equals(rhs);
				};

				ec.PointFp.prototype.toString = function () {
					return '(' + this.getX().toBigInteger().toString() + ',' + this.getY().toBigInteger().toString() + ')';
				};

				/**
				* Validate an elliptic curve point.
				*
				* See SEC 1, section 3.2.2.1: Elliptic Curve Public Key Validation Primitive
				*/
				ec.PointFp.prototype.validate = function () {
					var n = this.curve.getQ();

					// Check Q != O
					if (this.isInfinity()) {
						throw new Error("Point is at infinity.");
					}

					// Check coordinate bounds
					var x = this.getX().toBigInteger();
					var y = this.getY().toBigInteger();
					if (x.compareTo(BigInteger.ONE) < 0 || x.compareTo(n.subtract(BigInteger.ONE)) > 0) {
						throw new Error('x coordinate out of bounds');
					}
					if (y.compareTo(BigInteger.ONE) < 0 || y.compareTo(n.subtract(BigInteger.ONE)) > 0) {
						throw new Error('y coordinate out of bounds');
					}

					// Check y^2 = x^3 + ax + b (mod n)
					if (!this.isOnCurve()) {
						throw new Error("Point is not on the curve.");
					}

					// Check nQ = 0 (Q is a scalar multiple of G)
					if (this.multiply(n).isInfinity()) {
						// TODO: This check doesn't work - fix.
						throw new Error("Point is not a scalar multiple of G.");
					}

					return true;
				};




				// ----------------
				// ECCurveFp constructor
				ec.CurveFp = function (q, a, b) {
					this.q = q;
					this.a = this.fromBigInteger(a);
					this.b = this.fromBigInteger(b);
					this.infinity = new ec.PointFp(this, null, null);
					this.reducer = new Barrett(this.q);
				}

				ec.CurveFp.prototype.getQ = function () {
					return this.q;
				};

				ec.CurveFp.prototype.getA = function () {
					return this.a;
				};

				ec.CurveFp.prototype.getB = function () {
					return this.b;
				};

				ec.CurveFp.prototype.equals = function (other) {
					if (other == this) return true;
					return (this.q.equals(other.q) && this.a.equals(other.a) && this.b.equals(other.b));
				};

				ec.CurveFp.prototype.getInfinity = function () {
					return this.infinity;
				};

				ec.CurveFp.prototype.fromBigInteger = function (x) {
					return new ec.FieldElementFp(this.q, x);
				};

				ec.CurveFp.prototype.reduce = function (x) {
					this.reducer.reduce(x);
				};

				// for now, work with hex strings because they're easier in JS
				// compressed support added by bitaddress.org
				ec.CurveFp.prototype.decodePointHex = function (s) {
					var firstByte = parseInt(s.substr(0, 2), 16);
					switch (firstByte) { // first byte
						case 0:
							return this.infinity;
						case 2: // compressed
						case 3: // compressed
							var yTilde = firstByte & 1;
							var xHex = s.substr(2, s.length - 2);
							var X1 = new BigInteger(xHex, 16);
							return this.decompressPoint(yTilde, X1);
						case 4: // uncompressed
						case 6: // hybrid
						case 7: // hybrid
							var len = (s.length - 2) / 2;
							var xHex = s.substr(2, len);
							var yHex = s.substr(len + 2, len);

							return new ec.PointFp(this,
								this.fromBigInteger(new BigInteger(xHex, 16)),
								this.fromBigInteger(new BigInteger(yHex, 16)));

						default: // unsupported
							return null;
					}
				};

				ec.CurveFp.prototype.encodePointHex = function (p) {
					if (p.isInfinity()) return "00";
					var xHex = p.getX().toBigInteger().toString(16);
					var yHex = p.getY().toBigInteger().toString(16);
					var oLen = this.getQ().toString(16).length;
					if ((oLen % 2) != 0) oLen++;
					while (xHex.length < oLen) {
						xHex = "0" + xHex;
					}
					while (yHex.length < oLen) {
						yHex = "0" + yHex;
					}
					return "04" + xHex + yHex;
				};

				/*
				* Copyright (c) 2000 - 2011 The Legion Of The Bouncy Castle (http://www.bouncycastle.org)
				* Ported to JavaScript by bitaddress.org
				*
				* Number yTilde
				* BigInteger X1
				*/
				ec.CurveFp.prototype.decompressPoint = function (yTilde, X1) {
					var x = this.fromBigInteger(X1);
					var alpha = x.multiply(x.square().add(this.getA())).add(this.getB());
					var beta = alpha.sqrt();
					// if we can't find a sqrt we haven't got a point on the curve - run!
					if (beta == null) throw new Error("Invalid point compression");
					var betaValue = beta.toBigInteger();
					var bit0 = betaValue.testBit(0) ? 1 : 0;
					if (bit0 != yTilde) {
						// Use the other root
						beta = this.fromBigInteger(this.getQ().subtract(betaValue));
					}
					return new ec.PointFp(this, x, beta, null, true);
				};


				ec.fromHex = function (s) { return new BigInteger(s, 16); };

				ec.integerToBytes = function (i, len) {
					var bytes = i.toByteArrayUnsigned();
					if (len < bytes.length) {
						bytes = bytes.slice(bytes.length - len);
					} else while (len > bytes.length) {
						bytes.unshift(0);
					}
					return bytes;
				};


				// Named EC curves
				// ----------------
				// X9ECParameters constructor
				ec.X9Parameters = function (curve, g, n, h) {
					this.curve = curve;
					this.g = g;
					this.n = n;
					this.h = h;
				}
				ec.X9Parameters.prototype.getCurve = function () { return this.curve; };
				ec.X9Parameters.prototype.getG = function () { return this.g; };
				ec.X9Parameters.prototype.getN = function () { return this.n; };
				ec.X9Parameters.prototype.getH = function () { return this.h; };

				// secp256k1 is the Curve used by Bitcoin
				ec.secNamedCurves = {
					// used by Bitcoin
					"secp256k1": function () {
						// p = 2^256 - 2^32 - 2^9 - 2^8 - 2^7 - 2^6 - 2^4 - 1
						var p = ec.fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F");
						var a = BigInteger.ZERO;
						var b = ec.fromHex("7");
						var n = ec.fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141");
						var h = BigInteger.ONE;
						var curve = new ec.CurveFp(p, a, b);
						var G = curve.decodePointHex("04"
								+ "79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798"
								+ "483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8");
						return new ec.X9Parameters(curve, G, n, h);
					}
				};

				// secp256k1 called by Bitcoin's ECKEY
				ec.getSECCurveByName = function (name) {
					if (ec.secNamedCurves[name] == undefined) return null;
					return ec.secNamedCurves[name]();
				}
			})();

			/*
			CryptoJS v3.1.2
			code.google.com/p/crypto-js
			(c) 2009-2013 by Jeff Mott. All rights reserved.
			code.google.com/p/crypto-js/wiki/License
			*/
			/** @preserve
			(c) 2012 by Cdric Mesnil. All rights reserved.

			Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

			    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
			    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

			THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
			*/

			// Constants table
			var zl = [
			    0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
			    7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
			    3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
			    1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
			    4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13];
			var zr = [
			    5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
			    6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
			    15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
			    8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
			    12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11];
			var sl = [
			     11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
			    7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
			    11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
			      11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
			    9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ];
			var sr = [
			    8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
			    9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
			    9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
			    15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
			    8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ];

			var hl =  [ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E];
			var hr =  [ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000];

			var bytesToWords = function (bytes) {
			  var words = [];
			  for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {
			    words[b >>> 5] |= bytes[i] << (24 - b % 32);
			  }
			  return words;
			};

			var wordsToBytes = function (words) {
			  var bytes = [];
			  for (var b = 0; b < words.length * 32; b += 8) {
			    bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
			  }
			  return bytes;
			};

			var processBlock = function (H, M, offset) {

			  // Swap endian
			  for (var i = 0; i < 16; i++) {
			    var offset_i = offset + i;
			    var M_offset_i = M[offset_i];

			    // Swap
			    M[offset_i] = (
			        (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
			        (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
			    );
			  }

			  // Working variables
			  var al, bl, cl, dl, el;
			  var ar, br, cr, dr, er;

			  ar = al = H[0];
			  br = bl = H[1];
			  cr = cl = H[2];
			  dr = dl = H[3];
			  er = el = H[4];
			  // Computation
			  var t;
			  for (var i = 0; i < 80; i += 1) {
			    t = (al +  M[offset+zl[i]])|0;
			    if (i<16){
			        t +=  f1(bl,cl,dl) + hl[0];
			    } else if (i<32) {
			        t +=  f2(bl,cl,dl) + hl[1];
			    } else if (i<48) {
			        t +=  f3(bl,cl,dl) + hl[2];
			    } else if (i<64) {
			        t +=  f4(bl,cl,dl) + hl[3];
			    } else {// if (i<80) {
			        t +=  f5(bl,cl,dl) + hl[4];
			    }
			    t = t|0;
			    t =  rotl(t,sl[i]);
			    t = (t+el)|0;
			    al = el;
			    el = dl;
			    dl = rotl(cl, 10);
			    cl = bl;
			    bl = t;

			    t = (ar + M[offset+zr[i]])|0;
			    if (i<16){
			        t +=  f5(br,cr,dr) + hr[0];
			    } else if (i<32) {
			        t +=  f4(br,cr,dr) + hr[1];
			    } else if (i<48) {
			        t +=  f3(br,cr,dr) + hr[2];
			    } else if (i<64) {
			        t +=  f2(br,cr,dr) + hr[3];
			    } else {// if (i<80) {
			        t +=  f1(br,cr,dr) + hr[4];
			    }
			    t = t|0;
			    t =  rotl(t,sr[i]) ;
			    t = (t+er)|0;
			    ar = er;
			    er = dr;
			    dr = rotl(cr, 10);
			    cr = br;
			    br = t;
			  }
			  // Intermediate hash value
			  t    = (H[1] + cl + dr)|0;
			  H[1] = (H[2] + dl + er)|0;
			  H[2] = (H[3] + el + ar)|0;
			  H[3] = (H[4] + al + br)|0;
			  H[4] = (H[0] + bl + cr)|0;
			  H[0] =  t;
			};

			function f1(x, y, z) {
			  return ((x) ^ (y) ^ (z));
			}

			function f2(x, y, z) {
			  return (((x)&(y)) | ((~x)&(z)));
			}

			function f3(x, y, z) {
			  return (((x) | (~(y))) ^ (z));
			}

			function f4(x, y, z) {
			  return (((x) & (z)) | ((y)&(~(z))));
			}

			function f5(x, y, z) {
			  return ((x) ^ ((y) |(~(z))));
			}

			function rotl(x,n) {
			  return (x<<n) | (x>>>(32-n));
			}

			function ripemd160(message) {
			  var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];

			  var m = bytesToWords(message);

			  var nBitsLeft = message.length * 8;
			  var nBitsTotal = message.length * 8;

			  // Add padding
			  m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
			  m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
			      (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
			      (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
			  );

			  for (var i=0 ; i<m.length; i += 16) {
			    processBlock(H, m, i);
			  }

			  // Swap endian
			  for (var i = 0; i < 5; i++) {
			      // Shortcut
			    var H_i = H[i];

			    // Swap
			    H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
			          (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
			  }

			  var digestbytes = wordsToBytes(H);
			  return digestbytes;
			}
		</script>
		<style>
			@import url(https://volbil.github.io/entypo/entypo.css);
			[class*="entypo"]:before {
				font-family: 'EntypoRegular', sans-serif;
				font-size: 16px;
			}
			body {
				font-family: 'IBM Plex Mono', monospace;
				line-height: 1.5;
				font-size: 1rem;
				padding: 0;
				margin: 0;
			}
			table {
				padding: 0px 15px;
				font-size: 14px;
				width: 100%;
			}
			table th,
			table td {
				padding-right: 15px;
			}
			button {
				margin-left: 5px;
			}
			#search {
				margin: 20px 0px;
			}
			#pagination {
				font-size: 14px;
				max-width: 900px;
				margin: 0 auto;
				padding-bottom: 20px;
			}
			.mb-15 {
				margin-bottom: 15px;
			}
			.overflow {
				max-width: 100%;
				overflow-x: scroll;
			}
			.container {
				max-width: 1200px;
				margin: 0 auto;
				text-align: center;
			}
			.with-love {
				margin-top: 10px;
				padding-bottom: 46px;
				font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
			}
		</style>
		<script>
			/**
			 * A function for converting hex <-> dec w/o loss of precision.
			 *
			 * The problem is that parseInt("0x12345...") isn't precise enough to convert
			 * 64-bit integers correctly.
			 *
			 * Internally, this uses arrays to encode decimal digits starting with the least
			 * significant:
			 * 8 = [8]
			 * 16 = [6, 1]
			 * 1024 = [4, 2, 0, 1]
			 */

			// Adds two arrays for the given base (10 or 16), returning the result.
			// This turns out to be the only "primitive" operation we need.
			function add(x, y, base) {
			    var z = [];
			    var n = Math.max(x.length, y.length);
			    var carry = 0;
			    var i = 0;
			    while (i < n || carry) {
			        var xi = i < x.length ? x[i] : 0;
			        var yi = i < y.length ? y[i] : 0;
			        var zi = carry + xi + yi;
			        z.push(zi % base);
			        carry = Math.floor(zi / base);
			        i++;
			    }
			    return z;
			}

			// Returns a*x, where x is an array of decimal digits and a is an ordinary
			// JavaScript number. base is the number base of the array x.
			function multiplyByNumber(num, x, base) {
			    if (num < 0) return null;
			    if (num == 0) return [];

			    var result = [];
			    var power = x;
			    while (true) {
			        if (num & 1) {
			            result = add(result, power, base);
			        }
			        num = num >> 1;
			        if (num === 0) break;
			        power = add(power, power, base);
			    }

			    return result;
			}

			function parseToDigitsArray(str, base) {
			    var digits = str.split('');
			    var ary = [];
			    for (var i = digits.length - 1; i >= 0; i--) {
			        var n = parseInt(digits[i], base);
			        if (isNaN(n)) return null;
			        ary.push(n);
			    }
			    return ary;
			}

			function convertBase(str, fromBase, toBase) {
			    var digits = parseToDigitsArray(str, fromBase);
			    if (digits === null) return null;

			    var outArray = [];
			    var power = [1];
			    for (var i = 0; i < digits.length; i++) {
			        // invariant: at this point, fromBase^i = power
			        if (digits[i]) {
			            outArray = add(outArray, multiplyByNumber(digits[i], power, toBase), toBase);
			        }
			        power = multiplyByNumber(fromBase, power, toBase);
			    }

			    var out = '';
			    for (var i = outArray.length - 1; i >= 0; i--) {
			        out += outArray[i].toString(toBase);
			    }
			    return out;
			}

			function decToHex(decStr) {
			    var hex = convertBase(decStr, 10, 16);
			    return hex ? hex : null;
			}

			function hexToDec(hexStr) {
			    if (hexStr.substring(0, 2) === '0x') hexStr = hexStr.substring(2);
			    hexStr = hexStr.toLowerCase();
			    return convertBase(hexStr, 16, 10);
			}

			function hexToBytes(hex) {
			    for (var bytes = [], c = 0; c < hex.length; c += 2)
			    bytes.push(parseInt(hex.substr(c, 2), 16));
			    return bytes;
			}

			// Convert a byte array to a hex string
			function bytesToHex(bytes) {
			    for (var hex = [], i = 0; i < bytes.length; i++) {
			        hex.push((bytes[i] >>> 4).toString(16));
			        hex.push((bytes[i] & 0xF).toString(16));
			    }
			    return hex.join("");
			}

			function base58encode(source) {
				var alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
				var leader = alphabet.charAt(0)
			    if (source.length === 0) return ""

			    var digits = [0]
			    for (var i = 0; i < source.length; ++i) {
			        for (var j = 0, carry = source[i]; j < digits.length; ++j) {
			            carry += digits[j] << 8
			            digits[j] = carry % 58
			            carry = (carry / 58) | 0
			        }

			        while (carry > 0) {
			            digits.push(carry % 58)
			            carry = (carry / 58) | 0
			        }
			    }

			    var string = ""

			    // deal with leading zeros
			    for (var k = 0; source[k] === 0 && k < source.length - 1; ++k) string += leader
			    // convert digits to a string
			    for (var q = digits.length - 1; q >= 0; --q) string += alphabet[digits[q]]

			    return string
			}
		</script>
	</head>
	<body>
		<div class="container">
			<div id="search">
				<input id="page-go" style="width: 350px;" placeholder="Open page..." type="text">
				<button id="go">Go!</button>
				<button id="feellucky">Feel lucky?</button>
			</div>
			<div id="pagination">
				
			</div>
			<div id="content" class="overflow mb-15">
				<table style="text-align: left;" id="keys"></table>
			</div>
			<div class="with-love">
				Made with <span class="entypo heart text-danger" style="color: #dc3545;"></span> by <a target="_blank" href="https://github.com/volbil/bitcoin-addresses-list">Volbil</a>
			</div>
		</div>
	
		<script>
			perpage = "100" // Addresses per page
			total = "115792089237316195423570985008687907852837564279074904382605163141518161494337" // 1.158 * 10^77 (Bitcoin addresses space)
			max = StringMath.add(StringMath.divide(total, perpage).substring(0, StringMath.divide(total, perpage).indexOf('.')), "1") // Max pages
			
			// Get private key numbers based on page
			function getNumbers(page) {
				result = []
				page = StringMath.subtract(page, "1")
				page = StringMath.multiply(page, perpage)
				page = StringMath.add(page, "1")
				number = page

				while (result.length < perpage) {
					if (StringMath.compare(number, total) > -1) {
						break
					} else {
						result.push(number)
						number = StringMath.add(number, "1")
					}
				}

				return result
			}

			// Encode int to hex and get compressed/uncompresses WIF keys
			function getData(number) {
				key = decToHex(number).padStart(64, '0')
				compressed = getKey(key, true)
				uncompressed = getKey(key)

				return {"key": key, "compressed": compressed, "uncompressed": uncompressed}
			}

			// Get WIF private key from ECDSA private key
			function getKey(key, compressed = false) {
				end = compressed ? "01" : ""
				version = ("80" + key + end).toUpperCase()
				checksum = Crypto.SHA256(hexToBytes(Crypto.SHA256(hexToBytes(version)))).substring(0,8)
				wif = base58encode(hexToBytes(version + checksum))
				pubkey = getPubkey(key, compressed)
				address = getAddress(pubkey)

				return {"wif": wif, "pubkey": pubkey, "address": address}
			}

			// Get public key from WIF key
			function getPubkey(key, compressed = false) {
				var privateKeyBigInt = BigInteger.fromByteArrayUnsigned(hexToBytes(key))
				var curve = EllipticCurve.getSECCurveByName("secp256k1")

				var curvePt = curve.getG().multiply(privateKeyBigInt)
				var x = curvePt.getX().toBigInteger()
				var y = curvePt.getY().toBigInteger()

				var publicKeyBytes = EllipticCurve.integerToBytes(x, 32)
				publicKeyBytes = publicKeyBytes.concat(EllipticCurve.integerToBytes(y,32))
				publicKeyBytes.unshift(0x04)

				if(compressed){
					var publicKeyBytesCompressed = EllipticCurve.integerToBytes(x,32)
					if (y.isEven()){
						publicKeyBytesCompressed.unshift(0x02)
					} else {
						publicKeyBytesCompressed.unshift(0x03)
					}
					return bytesToHex(publicKeyBytesCompressed)
				} else {
					return bytesToHex(publicKeyBytes)
				}
			}

			// Get balance from set of addresses
			function getBalances(addrData) {
				banned = [
					"1BgGZ9tcN4rm9KBzDn7KprQz87SZ26SAMH" // This is address which correspond to number 1, and it breaks Blockchain API :D
				]
				addresses = addrData.filter( function(x) { return banned.indexOf(x) < 0; })
				get("https://blockchain.info/multiaddr?active=" + addresses.join("|") + "&n=1&cors=true").then(function(data) {
					result = JSON.parse(data)["addresses"]
					ishollyfuck = false
					for (var i = 0; i < result.length; i++) {
						address = result[i]["address"]
						ntx = result[i]["n_tx"]
						balance = result[i]["final_balance"]
						if (ntx > 0) { document.getElementById(address).style.background = "#ffff94" }
						if (balance > 0) {
							document.getElementById(address).style.background = "#90ee90"
							ishollyfuck = true
						}
						document.getElementById(address).getElementsByClassName("balance")[0].innerHTML = balance + " BTC"
					}

					if (ishollyfuck) {
						alert("Holly Fuck, you are lucky today!")
					}
				})
			}

			// Get address from public key
			function getAddress(h, byte) {
				var r = ripemd160(Crypto.SHA256(Crypto.util.hexToBytes(h), {asBytes: true}))
				r.unshift(byte || 0x00)
				var hash = Crypto.SHA256(Crypto.SHA256(r, {asBytes: true}), {asBytes: true})
				var checksum = hash.slice(0, 4)
				return base58encode(r.concat(checksum))
			}

			// Link to explorer
			function explorer(address) {
				return `<a target="_blank" href="https://www.blockchain.com/btc/address/${address}">${address}</a>`
			}

			// My little piece of (  )
			function feellucky() {
				page = ""
				data = Math.floor(Math.random() * (92913921392193 - 1)) + 1 + "God love Bitcoins" + Date.now()
				var result = "";
				for (i=0; i<data.length; i++) {
					hex = data.charCodeAt(i).toString(16)
					result += ("000"+hex).slice(-4);
				}

				hexData = Crypto.SHA256(hexToBytes(result))
				for (var i = 0; i < 64; i += 2) { page += parseInt(hexData.slice(i, i + 2), 16).toString() }
				
				lengthCheck = StringMath.compare(page, max) == 1

				while (lengthCheck) {
					page = (Math.floor(page.length % 2) == 1) ? page.substring(0, Math.floor(page.length / 2)) : page.substring(Math.floor(page.length / 2), page.length - 1)
					if ((parseInt(page[0]) % 2) == 1) { page = page.split("").reverse().join("") }
					if ((parseInt(page.substring(0,2) > parseInt(max.substring(0,2)) && page.length >= max.length))) { page = page.substring(2) }
					lengthCheck = StringMath.compare(page, max) == 1
				}

				if (page[0] == "0") { page = page.substring(1) }

				return page
			}

			// AJAX request
			function get(url) {
				return new Promise((resolve, reject) => {
					const req = new XMLHttpRequest()
					req.open('GET', url)
					req.onload = () => resolve(req.response)
					req.onerror = (e) => reject(Error(`Network Error: ${e}`))
					req.send()
				});
			}

			// Display this nice list of addresses
			function display(page = "1") {
				displayUncompressed = false
				numbers = getNumbers(page)
				addresses = []

				document.getElementById("keys").innerHTML = ""
				document.getElementById("pagination").innerHTML = `Page <b>${page}</b> from <b>${max}</b>`

				document.getElementById("keys").insertAdjacentHTML('beforeend', `
					<tr>
						<th scope="col">Address</th>
						<th scope="col" style="${displayUncompressed == true ? "" : "display:none"}">Type</th>
						<th scope="col">Key</th>
						<th scope="col">Balance</th>
					</tr>
				`)

				for (var i = 0; i < numbers.length; i++) {
					data = getData(numbers[i])
					addresses.push(data.compressed.address)
					if (displayUncompressed) {
						addresses.push(data.compressed.address)
					}
					document.getElementById("keys").insertAdjacentHTML('beforeend', `
						<tr id="${data.uncompressed.address}" style="${displayUncompressed == true ? "" : "display:none"}">
							<td>${explorer(data.uncompressed.address)}</td>
							<td style="${displayUncompressed == true ? "" : "display:none"}">Uncompressed</td>
							<td>${data.uncompressed.wif}</td>
							<td class="balance">Loading...</td>
						</tr>
						<tr id="${data.compressed.address}">
							<td>${explorer(data.compressed.address)}</td>
							<td style="${displayUncompressed == true ? "" : "display:none"}">Compressed</td>
							<td>${data.compressed.wif}</td>
							<td class="balance">Loading...</td>
						</tr>
					`)
				}

				if (numbers.length != 0) {
					getBalances(addresses)
				} else {
					display("1")
				}
			}

			// Go to page
			document.getElementById("go").onclick = function() {
				page = document.getElementById("page-go").value
				if(!isNaN(page)) {
					display(page)
				}
			}

			// Do you feel lucky today?
			document.getElementById("feellucky").onclick = function() {
				page = feellucky()
				if(!isNaN(page)) {
					display(page)
				}
			}

			// Go to page by pressing enter key
			document.getElementById("page-go").addEventListener("keyup", function(event) {
				event.preventDefault();
				if (event.keyCode === 13) {
					page = document.getElementById("page-go").value
					if(!isNaN(page)) {
						display(page)
					}
				}
			});

			// Lets launch this maching :D
			(function() {
				display()
			})();
		</script>
	</body>
</html>